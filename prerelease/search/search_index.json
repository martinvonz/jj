{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"FAQ.html","title":"Frequently asked questions","text":""},{"location":"FAQ.html#why-does-my-branch-not-move-to-the-new-commit-after-jj-newcommit","title":"Why does my branch not move to the new commit after <code>jj new/commit</code>?","text":"<p>If you're familiar with Git, you might expect the current branch to move forward when you commit. However, Jujutsu does not have a concept of a \"current branch\".</p> <p>To move branches, use <code>jj branch set</code>.</p>"},{"location":"FAQ.html#i-made-a-commit-and-jj-git-push-all-says-nothing-changed-instead-of-pushing-it-what-do-i-do","title":"I made a commit and <code>jj git push --all</code> says \"Nothing changed\" instead of pushing it. What do I do?","text":"<p><code>jj git push --all</code> pushes all branches, not all revisions. You have two options:</p> <ul> <li>Using <code>jj git push --change</code> will automatically create a branch and push it.</li> <li>Using <code>jj branch</code> commands to create or move a branch to either the commit   you want to push or a descendant on it. Unlike Git, Jujutsu doesn't do this   automatically (see previous question).</li> </ul>"},{"location":"FAQ.html#where-is-my-commit-why-is-it-not-visible-in-jj-log","title":"Where is my commit, why is it not visible in <code>jj log</code>?","text":"<p>Is your commit visible with <code>jj log -r 'all()'</code>?</p> <p>If yes, you should be aware that <code>jj log</code> only shows the revisions matching <code>revsets.log</code> by default. You can change it as described in config to show more revisions.</p> <p>If not, the revision may have been abandoned (e.g. because you used <code>jj abandon</code>, or because it's an obsolete version that's been rewritten with <code>jj rebase</code>, <code>jj describe</code>, etc). In that case, <code>jj log -r commit_id</code> should show the revision as \"hidden\". <code>jj new commit_id</code> should make the revision visible again.</p> <p>See revsets and templates for further guidance.</p>"},{"location":"FAQ.html#can-i-prevent-jujutsu-from-recording-my-unfinished-work-im-not-ready-to-commit-it","title":"Can I prevent Jujutsu from recording my unfinished work? I'm not ready to commit it.","text":"<p>Jujutsu automatically records new files in the current working-copy commit and doesn't provide a way to prevent that.</p> <p>However, you can easily record intermediate drafts of your work. If you think you might want to go back to the current state of the working-copy commit, simply use <code>jj new</code>. There's no need for the commit to be \"finished\" or even have a description.</p> <p>Then future edits will go into a new working-copy commit on top of the now former working-copy commit. Whenever you are happy with another set of edits, use <code>jj squash</code> to amend the previous commit.</p> <p>For more options see the next question.</p>"},{"location":"FAQ.html#can-i-add-a-portion-of-the-edits-i-made-to-a-file-similarly-to-git-add-p-or-hg-commit-i","title":"Can I add a portion of the edits I made to a file, similarly to <code>git add -p</code> or <code>hg commit -i</code>?","text":"<p>At the moment the best options to partially add a file are: <code>jj split</code>, <code>jj amend -i</code> and <code>jj move -i</code>.</p>"},{"location":"FAQ.html#is-there-something-like-git-rebase-interactive-or-hg-histedit","title":"Is there something like <code>git rebase --interactive</code> or <code>hg histedit</code>?","text":"<p>Not yet, you can check this issue for updates.</p> <p>To reorder commits, it is for now recommended to rebase commits individually, which may require multiple invocations of <code>jj rebase -r</code> or <code>jj rebase -s</code>.</p> <p>To squash or split commits, use <code>jj squash</code> and <code>jj split</code>.</p>"},{"location":"FAQ.html#how-can-i-keep-my-scratch-files-in-the-repository","title":"How can I keep my scratch files in the repository?","text":"<p>You can keep your notes and other scratch files in the repository, if you add a wildcard pattern to either the repo's <code>gitignore</code> or your global <code>gitignore</code>. Something like <code>*.scratch</code> or <code>*.scratchpad</code> should do, after that rename the files you want to keep around to match the pattern.</p> <p>If <code>$EDITOR</code> integration is important, something like <code>scratchpad.*</code> may be more helpful, as you can keep the filename extension intact (it matches <code>scratchpad.md</code>, <code>scratchpad.rs</code> and more).</p> <p>You can find more details on <code>gitignore</code> files here.</p>"},{"location":"FAQ.html#how-can-i-keep-local-changes-around-but-not-use-them-for-pull-requests","title":"How can I keep local changes around, but not use them for Pull Requests?","text":"<p>In general, you should separate out the changes to their own commit (using e.g. <code>jj split</code>). After that, one possible workflow is to rebase your pending PRs on top of the commit with the local changes. Then, just before pushing to a remote, use <code>jj rebase -s child_of_commit_with_local_changes -d main</code> to move the PRs back on top of <code>main</code>.</p> <p>If you have several PRs, you can try <code>jj rebase -s all:commit_with_local_changes+ -d main</code> (note the <code>+</code>) to move them all at once.</p> <p>An alternative workflow would be to rebase the commit with local changes on top of the PR you're working on and then do <code>jj new commit_with_local_changes</code>. You'll then need to use <code>jj new --before</code> to create new commits and <code>jj move --to</code> to move new changes into the correct commits.</p>"},{"location":"FAQ.html#i-accidentally-amended-the-working-copy-how-do-i-move-the-new-changes-into-its-own-commit","title":"I accidentally amended the working copy. How do I move the new changes into its own commit?","text":"<p>Use <code>jj obslog -p</code> to see how your working-copy commit has evolved. Find the commit you want to restore the contents to. Let's say the current commit (with the changes intended for a new commit) are in commit X and the state you wanted is in commit Y. Note the commit id (normally in blue at the end of the line in the log output) of each of them. Now use <code>jj new</code> to create a new working-copy commit, then run <code>jj restore --from Y --to @-</code> to restore the parent commit to the old state, and <code>jj restore --from X</code> to restore the new working-copy commit to the new state.</p>"},{"location":"branches.html","title":"Branches","text":""},{"location":"branches.html#introduction","title":"Introduction","text":"<p>Branches are named pointers to revisions (just like they are in Git). You can move them without affecting the target revision's identity. Branches automatically move when revisions are rewritten (e.g. by <code>jj rebase</code>). You can pass a branch's name to commands that want a revision as argument. For example, <code>jj co main</code> will check out the revision pointed to by the \"main\" branch. Use <code>jj branch list</code> to list branches and <code>jj branch</code> to create, move, or delete branches. There is currently no concept of an active/current/checked-out branch.</p>"},{"location":"branches.html#remotes","title":"Remotes","text":"<p>Jujutsu identifies a branch by its name across remotes (this is unlike Git and more like Mercurial's \"bookmarks\"). For example, a branch called \"main\" in your local repo is considered the same branch as a branch by the same name on a remote. When you pull from a remote (currently only via <code>jj git fetch</code>), any branches from the remote will be imported as branches in your local repo.</p> <p>Jujutsu also records the last seen position on each remote (just like Git's remote-tracking branches). You can refer to these with <code>&lt;branch name&gt;@&lt;remote name&gt;</code>, such as <code>jj new main@origin</code>. Most commands don't show the remote branch if it has the same target as the local branch. The local branch (without <code>@&lt;remote name&gt;</code>) is considered the branch's desired target. Consequently, if you want to update a branch on a remote, you first update the branch locally and then push the update to the remote. If a local branch also exists on some remote but points to a different target there, <code>jj log</code> will show the branch name with an asterisk suffix (e.g. <code>main*</code>). That is meant to remind you that you may want to push the branch to some remote.</p> <p>When you pull from a remote, any changes compared to the current record of the remote's state will be propagated to the local branch. Let's say you run <code>jj git fetch --remote origin</code> and the remote's \"main\" branch has moved so its target is now ahead of the local record in <code>main@origin</code>. That will update <code>main@origin</code> to the new target. It will also apply the change to the local branch <code>main</code>. If the local target had also moved compared to <code>main@origin</code> (probably because you had run <code>jj branch set main</code>), then the two updates will be merged. If one is ahead of the other, then that target will be the new target. Otherwise, the local branch will be conflicted (see next section for details).</p>"},{"location":"branches.html#conflicts","title":"Conflicts","text":"<p>Branches can end up in a conflicted state. When that happens, <code>jj status</code> will include information about the conflicted branches (and instructions for how to mitigate it). <code>jj branch list</code> will have details. <code>jj log</code> will show the branch name with a question mark suffix (e.g. <code>main?</code>) on each of the conflicted branch's potential target revisions. Using the branch name to look up a revision will resolve to all potential targets. That means that <code>jj co main</code> will error out, complaining that the revset resolved to multiple revisions.</p> <p>Both local branches (e.g. <code>main</code>) and the remote branch (e.g. <code>main@origin</code>) can have conflicts. Both can end up in that state if concurrent operations were run in the repo. The local branch more typically becomes conflicted because it was updated both locally and on a remote.</p> <p>To resolve a conflicted state in a local branch (e.g. <code>main</code>), you can move the branch to the desired target with <code>jj branch</code>. You may want to first either merge the conflicted targets with <code>jj merge</code>, or you may want to rebase one side on top of the other with <code>jj rebase</code>.</p> <p>To resolve a conflicted state in a remote branch (e.g. <code>main@origin</code>), simply pull from the remote (e.g. <code>jj git fetch</code>). The conflict resolution will also propagate to the local branch (which was presumably also conflicted).</p>"},{"location":"code-of-conduct.html","title":"Code of Conduct","text":""},{"location":"code-of-conduct.html#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code-of-conduct.html#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or     advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic     address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a     professional setting</li> </ul>"},{"location":"code-of-conduct.html#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code-of-conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p> <p>This Code of Conduct also applies outside the project spaces when the Project Steward has a reasonable belief that an individual's behavior may have a negative impact on the project or its community.</p>"},{"location":"code-of-conduct.html#conflict-resolution","title":"Conflict Resolution","text":"<p>We do not believe that all conflict is bad; healthy debate and disagreement often yield positive results. However, it is never okay to be disrespectful or to engage in behavior that violates the project\u2019s code of conduct.</p> <p>If you see someone violating the code of conduct, you are encouraged to address the behavior directly with those involved. Many issues can be resolved quickly and easily, and this gives people more control over the outcome of their dispute. If you are unable to resolve the matter for any reason, or if the behavior is threatening or harassing, report it. We are dedicated to providing an environment where participants feel welcome and safe.</p> <p>Reports should be directed to [PROJECT STEWARD NAME(s) AND EMAIL(s)], the Project Steward(s) for [PROJECT NAME]. It is the Project Steward\u2019s duty to receive and address reported violations of the code of conduct. They will then work with a committee consisting of representatives from the Open Source Programs Office and the Google Open Source Strategy team. If for any reason you are uncomfortable reaching out to the Project Steward, please email opensource@google.com.</p> <p>We will investigate every complaint, but you may not receive a direct response. We will use our discretion in determining when and how to follow up on reported incidents, which may range from not taking action to permanent expulsion from the project and project-sponsored spaces. We will notify the accused of the report and provide them an opportunity to discuss it before any action is taken. The identity of the reporter will be omitted from the details of the report supplied to the accused. In potentially harmful situations, such as ongoing harassment or threats to anyone's safety, we may take action without notice.</p>"},{"location":"code-of-conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p>"},{"location":"config.html","title":"Configuration","text":"<p>These are the config settings available to jj/Jujutsu.</p>"},{"location":"config.html#config-files-and-toml","title":"Config files and TOML","text":"<p>The config settings are loaded from the following locations. Less common ways to specify <code>jj</code> config settings are discussed in a later section.</p> <ul> <li>The user config file</li> <li><code>.jj/repo/config.toml</code> (per-repository)</li> </ul> <p>See the TOML site and the syntax guide for a description of the syntax.</p> <p>The first thing to remember is that the value of a setting (the part to the right of the <code>=</code> sign) should be surrounded in quotes if it's a string.</p>"},{"location":"config.html#dotted-style-and-headings","title":"Dotted style and headings","text":"<p>In TOML, anything under a heading can be dotted instead. For example, <code>user.name = \"YOUR NAME\"</code> is equivalent to:</p> <pre><code>[user]\nname = \"YOUR NAME\"\n</code></pre> <p>For future reference, here are a couple of more complicated examples,</p> <pre><code># Dotted style\ntemplate-aliases.\"format_short_id(id)\" = \"id.shortest(12)\"\ncolors.\"commit_id prefix\".bold = true\n\n# is equivalent to:\n[template-aliases]\n\"format_short_id(id)\" = \"id.shortest(12)\"\n\n[colors]\n\"commit_id prefix\" = { bold = true }\n</code></pre> <p>Jujutsu favors the dotted style in these instructions, if only because it's easier to write down in an unconfusing way. If you are confident with TOML then use whichever suits you in your config. If you mix dotted keys and headings, put the dotted keys before the first heading.</p> <p>That's probably enough TOML to keep you out of trouble but the syntax guide is very short if you ever need to check.</p>"},{"location":"config.html#user-settings","title":"User settings","text":"<pre><code>user.name = \"YOUR NAME\"\nuser.email = \"YOUR_EMAIL@example.com\"\n</code></pre> <p>Don't forget to change these to your own details!</p>"},{"location":"config.html#ui-settings","title":"UI settings","text":""},{"location":"config.html#colorizing-output","title":"Colorizing output","text":"<p>Possible values are <code>always</code>, <code>never</code> and <code>auto</code> (default: <code>auto</code>). <code>auto</code> will use color only when writing to a terminal.</p> <p>This setting overrides the <code>NO_COLOR</code> environment variable (if set).</p> <pre><code>ui.color = \"never\" # Turn off color\n</code></pre>"},{"location":"config.html#custom-colors-and-styles","title":"Custom colors and styles","text":"<p>You can customize the colors used for various elements of the UI. For example:</p> <pre><code>colors.commit_id = \"green\"\n</code></pre> <p>The following colors are available:</p> <ul> <li>black</li> <li>red</li> <li>green</li> <li>yellow</li> <li>blue</li> <li>magenta</li> <li>cyan</li> <li>white</li> <li>default</li> </ul> <p>All of them but \"default\" come in a bright version too, e.g. \"bright red\". The \"default\" color can be used to override a color defined by a parent style (explained below).</p> <p>If you use a string value for a color, as in the example above, it will be used for the foreground color. You can also set the background color, or make the text bold or underlined. For that, you need to use a table:</p> <pre><code>colors.commit_id = { fg = \"green\", bg = \"red\", bold = true, underline = true }\n</code></pre> <p>The key names are called \"labels\". The above used <code>commit_id</code> as label. You can also create rules combining multiple labels. The rules work a bit like CSS selectors. For example, if you want to color commit IDs green in general but make the commit ID of the working-copy commit also be underlined, you can do this:</p> <pre><code>colors.commit_id = \"green\"\ncolors.\"working_copy commit_id\" = { underline = true }\n</code></pre> <p>Parts of the style that are not overridden - such as the foreground color in the example above - are inherited from the parent style.</p> <p>Which elements can be colored is not yet documented, but see the default color configuration for some examples of what's possible.</p>"},{"location":"config.html#default-command","title":"Default command","text":"<p>When <code>jj</code> is run with no explicit subcommand, the value of the <code>ui.default-command</code> setting will be used instead. Possible values are any valid subcommand name, subcommand alias, or user-defined alias (defaults to <code>\"log\"</code>).</p> <pre><code>ui.default-command = \"log\"\n</code></pre>"},{"location":"config.html#default-description","title":"Default description","text":"<p>The value of the <code>ui.default-description</code> setting will be used to prepopulate the editor when describing changes with an empty description. This could be a useful reminder to fill in things like BUG=, TESTED= etc.</p> <pre><code>ui.default-description = \"\\n\\nTESTED=TODO\"\n</code></pre>"},{"location":"config.html#diff-format","title":"Diff format","text":"<pre><code># Possible values: \"color-words\" (default), \"git\", \"summary\"\nui.diff.format = \"git\"\n</code></pre>"},{"location":"config.html#generating-diffs-by-external-command","title":"Generating diffs by external command","text":"<p>If <code>ui.diff.tool</code> is set, the specified diff command will be called instead of the internal diff function.</p> <pre><code># Use Difftastic by default\nui.diff.tool = [\"difft\", \"--color=always\", \"$left\", \"$right\"]\n# Use tool named \"&lt;name&gt;\" (see below)\nui.diff.tool = \"&lt;name&gt;\"\n</code></pre> <p>The external diff tool can also be enabled by <code>diff --tool &lt;name&gt;</code> argument. For the tool named <code>&lt;name&gt;</code>, command arguments can be configured as follows.</p> <pre><code>[merge-tools.&lt;name&gt;]\n# program = \"&lt;name&gt;\"  # Defaults to the name of the tool if not specified\ndiff-args = [\"--color=always\", \"$left\", \"$right\"]\n</code></pre> <ul> <li><code>$left</code> and <code>$right</code> are replaced with the paths to the left and right   directories to diff respectively.</li> </ul>"},{"location":"config.html#default-revisions-to-log","title":"Default revisions to log","text":"<p>You can configure the revisions <code>jj log</code> without <code>-r</code> should show.</p> <pre><code># Show commits that are not in `main`\nrevsets.log = \"main..\"\n</code></pre>"},{"location":"config.html#graph-style","title":"Graph style","text":"<pre><code># Possible values: \"curved\" (default), \"square\", \"ascii\", \"ascii-large\",\n# \"legacy\"\nui.graph.style = \"square\"\n</code></pre>"},{"location":"config.html#wrap-log-content","title":"Wrap log content","text":"<p>If enabled, <code>log</code>/<code>obslog</code>/<code>op log</code> content will be wrapped based on the terminal width.</p> <pre><code>ui.log-word-wrap = true\n</code></pre>"},{"location":"config.html#display-of-commit-and-change-ids","title":"Display of commit and change ids","text":"<p>Can be customized by the <code>format_short_id()</code> template alias.</p> <pre><code>[template-aliases]\n# Highlight unique prefix and show at least 12 characters (default)\n'format_short_id(id)' = 'id.shortest(12)'\n# Just the shortest possible unique prefix\n'format_short_id(id)' = 'id.shortest()'\n# Show unique prefix and the rest surrounded by brackets\n'format_short_id(id)' = 'id.shortest(12).prefix() ++ \"[\" ++ id.shortest(12).rest() ++ \"]\"'\n# Always show 12 characters\n'format_short_id(id)' = 'id.short(12)'\n</code></pre> <p>To customize these separately, use the <code>format_short_commit_id()</code> and <code>format_short_change_id()</code> aliases:</p> <pre><code>[template-aliases]\n# Uppercase change ids. `jj` treats change and commit ids as case-insensitive.\n'format_short_change_id(id)' = 'format_short_id(id).upper()'\n</code></pre> <p>To get shorter prefixes for certain revisions, set <code>revsets.short-prefixes</code>:</p> <pre><code># Prioritize the current branch\nrevsets.short-prefixes = \"(main..@)::\"\n</code></pre>"},{"location":"config.html#relative-timestamps","title":"Relative timestamps","text":"<p>Can be customized by the <code>format_timestamp()</code> template alias.</p> <pre><code>[template-aliases]\n# Full timestamp in ISO 8601 format (default)\n'format_timestamp(timestamp)' = 'timestamp'\n# Relative timestamp rendered as \"x days/hours/seconds ago\"\n'format_timestamp(timestamp)' = 'timestamp.ago()'\n</code></pre> <p><code>jj op log</code> defaults to relative timestamps. To use absolute timestamps, you will need to modify the <code>format_time_range()</code> template alias.</p> <pre><code>[template-aliases]\n'format_time_range(time_range)' = 'time_range.start() ++ \" - \" ++ time_range.end()'\n</code></pre>"},{"location":"config.html#author-format","title":"Author format","text":"<p>Can be customized by the <code>format_short_signature()</code> template alias.</p> <pre><code>[template-aliases]\n# Full email address (default)\n'format_short_signature(signature)' = 'signature.email()'\n# Both name and email address\n'format_short_signature(signature)' = 'signature'\n# Username part of the email address\n'format_short_signature(signature)' = 'signature.username()'\n</code></pre>"},{"location":"config.html#pager","title":"Pager","text":"<p>Windows users: Note that pagination is disabled by default on Windows for now (#2040).</p> <p>The default pager is can be set via <code>ui.pager</code> or the <code>PAGER</code> environment variable. The priority is as follows (environment variables are marked with a <code>$</code>):</p> <p><code>ui.pager</code> &gt; <code>$PAGER</code></p> <p><code>less -FRX</code> is the default pager in the absence of any other setting.</p> <p>Additionally, paging behavior can be toggled via <code>ui.paginate</code> like so:</p> <pre><code># Enable pagination for commands that support it (default)\nui.paginate = \"auto\"\n# Disable all pagination, equivalent to using --no-pager\nui.paginate = \"never\"\n</code></pre>"},{"location":"config.html#processing-contents-to-be-paged","title":"Processing contents to be paged","text":"<p>If you'd like to pass the output through a formatter e.g. <code>diff-so-fancy</code> before piping it through a pager you must do it using a subshell as, unlike <code>git</code> or <code>hg</code>, the command will be executed directly. For example:</p> <p><code>ui.pager = [\"sh\", \"-c\", \"diff-so-fancy | less -RFX\"]</code></p>"},{"location":"config.html#aliases","title":"Aliases","text":"<p>You can define aliases for commands, including their arguments. For example:</p> <pre><code># `jj l` shows commits on the working-copy commit's (anonymous) branch\n# compared to the `main` branch\naliases.l = [\"log\", \"-r\", \"(main..@):: | (main..@)-\"]\n</code></pre>"},{"location":"config.html#editor","title":"Editor","text":"<p>The default editor is set via <code>ui.editor</code>, though there are several places to set it. The priority is as follows (environment variables are marked with a <code>$</code>):</p> <p><code>$JJ_EDITOR</code> &gt; <code>ui.editor</code> &gt; <code>$VISUAL</code> &gt; <code>$EDITOR</code></p> <p>Pico is the default editor (Notepad on Windows) in the absence of any other setting, but you could set it explicitly too.</p> <pre><code>ui.editor = \"pico\"\n</code></pre> <p>To use NeoVim instead:</p> <pre><code>ui.editor = \"nvim\"\n</code></pre> <p>For GUI editors you possibly need to use a <code>-w</code> or <code>--wait</code>. Some examples:</p> <pre><code>ui.editor = \"code -w\"       # VS Code\nui.editor = \"bbedit -w\"     # BBEdit\nui.editor = \"subl -n -w\"    # Sublime Text\nui.editor = \"mate -w\"       # TextMate\nui.editor = [\"C:/Program Files/Notepad++/notepad++.exe\",\n\"-multiInst\", \"-notabbar\", \"-nosession\", \"-noPlugin\"] # Notepad++\nui.editor = \"idea --temp-project --wait\"   #IntelliJ\n</code></pre> <p>Obviously, you would only set one line, don't copy them all in!</p>"},{"location":"config.html#editing-diffs","title":"Editing diffs","text":"<p>The <code>ui.diff-editor</code> setting affects the tool used for editing diffs (e.g. <code>jj split</code>, <code>jj amend -i</code>). The default is <code>meld</code>.</p> <p><code>jj</code> makes the following substitutions:</p> <ul> <li><code>$left</code> and <code>$right</code> are replaced with the paths to the left and right   directories to diff respectively.</li> </ul> <p>If no arguments are specified, <code>[\"$left\", \"$right\"]</code> are set by default.</p> <p>For example:</p> <pre><code># Use merge-tools.kdiff3.edit-args\nui.diff-editor = \"kdiff3\"\n# Specify edit-args inline\nui.diff-editor = [\"kdiff3\", \"--merge\", \"$left\", \"$right\"]\n</code></pre> <p>If <code>ui.diff-editor</code> consists of a single word, e.g. <code>\"kdiff3\"</code>, the arguments will be read from the following config keys.</p> <pre><code># merge-tools.kdiff3.program = \"kdiff3\"      # Defaults to the name of the tool if not specified\nmerge-tools.kdiff3.edit-args = [\n\"--merge\", \"--cs\", \"CreateBakFiles=0\", \"$left\", \"$right\"]\n</code></pre>"},{"location":"config.html#experimental-3-pane-diff-editing","title":"Experimental 3-pane diff editing","text":"<p>The special <code>\"meld-3\"</code> diff editor sets up Meld to show 3 panes: the sides of the diff on the left and right, and an editing pane in the middle. This allow you to see both sides of the original diff while editing. If you use <code>ui.diff-editor = \"meld-3\"</code>, note that you can still get the 2-pane Meld view using <code>jj diff --tool meld</code>.</p> <p>To configure other diff editors, you can include <code>$output</code> together with <code>$left</code> and <code>$right</code> in <code>merge-tools.TOOL.edit-args</code>. <code>jj</code> will replace <code>$output</code> with the directory where the diff editor will be expected to put the result of the user's edits. Initially, the contents of <code>$output</code> will be the same as the contents of <code>$right</code>.</p>"},{"location":"config.html#setting-up-scm-diff-editor","title":"Setting up <code>scm-diff-editor</code>","text":"<p><code>scm-diff-editor</code> is a terminal-based diff editor that is part of the git-branchless suite of tools. It's a good alternative to Meld, especially if you don't have a graphical environment (e.g. when using SSH). To install it:</p> <pre><code>cargo install --git https://github.com/arxanas/git-branchless scm-record --features scm-diff-editor\n</code></pre> <p>Then config it as follows:</p> <pre><code>ui.diff-editor = [\"scm-diff-editor\", \"--dir-diff\", \"$left\", \"$right\"]\n</code></pre>"},{"location":"config.html#jj-instructions","title":"<code>JJ-INSTRUCTIONS</code>","text":"<p>When editing a diff, jj will include a synthetic file called <code>JJ-INSTRUCTIONS</code> in the diff with instructions on how to edit the diff. Any changes you make to this file will be ignored. To suppress the creation of this file, set <code>ui.diff-instructions = false</code>.</p>"},{"location":"config.html#using-vim-as-a-diff-editor","title":"Using Vim as a diff editor","text":"<p>Using <code>ui.diff-editor = \"vimdiff\"</code> is possible but not recommended. For a better experience, you can follow these instructions to configure the DirDiff Vim plugin and/or the vimtabdiff Python script.</p>"},{"location":"config.html#3-way-merge-tools-for-conflict-resolution","title":"3-way merge tools for conflict resolution","text":"<p>The <code>ui.merge-editor</code> key specifies the tool used for three-way merge tools by <code>jj resolve</code>. For example:</p> <pre><code># Use merge-tools.meld.merge-args\nui.merge-editor = \"meld\"  # Or \"kdiff3\" or \"vimdiff\"\n# Specify merge-args inline\nui.merge-editor = [\"meld\", \"$left\", \"$base\", \"$right\", \"-o\", \"$output\"]\n</code></pre> <p>The \"meld\", \"kdiff3\", and \"vimdiff\" tools can be used out of the box, as long as they are installed.</p> <p>To use a different tool named <code>TOOL</code>, the arguments to pass to the tool MUST be specified either inline or in the <code>merge-tools.TOOL.merge-args</code> key. As an example of how to set this key and other tool configuration options, here is the out-of-the-box configuration of the three default tools. (There is no need to copy it to your config file verbatim, but you are welcome to customize it.)</p> <pre><code># merge-tools.kdiff3.program  = \"kdiff3\"     # Defaults to the name of the tool if not specified\nmerge-tools.kdiff3.merge-args = [\"$base\", \"$left\", \"$right\", \"-o\", \"$output\", \"--auto\"]\nmerge-tools.meld.merge-args = [\"$left\", \"$base\", \"$right\", \"-o\", \"$output\", \"--auto-merge\"]\n\nmerge-tools.vimdiff.merge-args = [\"-f\", \"-d\", \"$output\", \"-M\",\n\"$left\", \"$base\", \"$right\",\n\"-c\", \"wincmd J\", \"-c\", \"set modifiable\",\n\"-c\", \"set write\"]\nmerge-tools.vimdiff.program = \"vim\"\nmerge-tools.vimdiff.merge-tool-edits-conflict-markers = true    # See below for an explanation\n</code></pre> <p><code>jj</code> makes the following substitutions:</p> <ul> <li> <p><code>$output</code> (REQUIRED) is replaced with the name of the file that the merge tool   should output. <code>jj</code> will read this file after the merge tool exits.</p> </li> <li> <p><code>$left</code> and <code>$right</code> are replaced with the paths to two files containing the   content of each side of the conflict.</p> </li> <li> <p><code>$base</code> is replaced with the path to a file containing the contents of the   conflicted file in the last common ancestor of the two sides of the conflict.</p> </li> </ul>"},{"location":"config.html#editing-conflict-markers-with-a-tool-or-a-text-editor","title":"Editing conflict markers with a tool or a text editor","text":"<p>By default, the merge tool starts with an empty output file. If the tool puts anything into the output file, and exits with the 0 exit code, <code>jj</code> assumes that the conflict is fully resolved. This is appropriate for most graphical merge tools.</p> <p>Some tools (e.g. <code>vimdiff</code>) can present a multi-way diff but don't resolve conflict themselves. When using such tools, <code>jj</code> can help you by populating the output file with conflict markers before starting the merge tool (instead of leaving the output file empty and letting the merge tool fill it in). To do that, set the <code>merge-tools.vimdiff.merge-tool-edits-conflict-markers = true</code> option.</p> <p>With this option set, if the output file still contains conflict markers after the conflict is done, <code>jj</code> assumes that the conflict was only partially resolved and parses the conflict markers to get the new state of the conflict. The conflict is considered fully resolved when there are no conflict markers left.</p>"},{"location":"config.html#git-settings","title":"Git settings","text":""},{"location":"config.html#automatic-local-branch-creation","title":"Automatic local branch creation","text":"<p>By default, when <code>jj</code> imports a remote-tracking branch from Git, it also creates a local branch with the same name. In some repositories, this may be undesirable, e.g.:</p> <ul> <li>There is a remote with a lot of historical branches that you don't   want to be exported to the co-located Git repo.</li> <li>There are multiple remotes with conflicting views of that branch,   resulting in an unhelpful conflicted state.</li> </ul> <p>You can disable this behavior by setting <code>git.auto-local-branch</code> like so,</p> <pre><code>git.auto-local-branch = false\n</code></pre> <p>Note that this setting may make it easier to accidentally delete remote branches. Since the local branch isn't created, the remote branch will be deleted if you push the branch with <code>jj git push --branch</code> or <code>jj git push --all</code>.</p>"},{"location":"config.html#prefix-for-generated-branches-on-push","title":"Prefix for generated branches on push","text":"<p><code>jj git push --change</code> generates branch names with a prefix of \"push-\" by default. You can pick a different prefix by setting <code>git.push-branch-prefix</code>. For example:</p> <pre><code>git.push-branch-prefix = \"martinvonz/push-\"\n</code></pre>"},{"location":"config.html#filesystem-monitor","title":"Filesystem monitor","text":"<p>In large repositories, it may be beneficial to use a \"filesystem monitor\" to track changes to the working copy. This allows <code>jj</code> to take working copy snapshots without having to rescan the entire working copy.</p>"},{"location":"config.html#watchman","title":"Watchman","text":"<p>To configure the Watchman filesystem monitor, set <code>core.fsmonitor = \"watchman\"</code>. Ensure that you have installed the Watchman executable on your system.</p> <p>Debugging commands are available under <code>jj debug watchman</code>.</p>"},{"location":"config.html#user-config-file","title":"User config file","text":"<p>On all platforms, the user's global <code>jj</code> configuration file is located at either <code>~/.jjconfig.toml</code> (where <code>~</code> represents <code>$HOME</code> on Unix-likes, or <code>%USERPROFILE%</code> on Windows) or in a platform-specific directory. The platform-specific location is recommended for better integration with platform services. It is an error for both of these files to exist.</p> Platform Value Example Linux <code>$XDG_CONFIG_HOME/jj/config.toml</code> <code>/home/alice/.config/jj/config.toml</code> macOS <code>$HOME/Library/Application Support/jj/config.toml</code> <code>/Users/Alice/Library/Application Support/jj/config.toml</code> Windows <code>{FOLDERID_RoamingAppData}\\jj\\config.toml</code> <code>C:\\Users\\Alice\\AppData\\Roaming\\jj\\config.toml</code> <p>The location of the <code>jj</code> config file can also be overridden with the <code>JJ_CONFIG</code> environment variable. If it is not empty, it should contain the path to a TOML file that will be used instead of any configuration file in the default locations. For example,</p> <pre><code>env JJ_CONFIG=/dev/null jj log       # Ignores any settings specified in the config file.\n</code></pre> <p>You can use one or more <code>--config-toml</code> options on the command line to specify additional configuration settings. This overrides settings defined in config files or environment variables. For example,</p> <pre><code>jj --config-toml='ui.color=\"always\"' --config-toml='ui.diff-editor=\"kdiff3\"' split\n</code></pre> <p>Config specified this way must be valid TOML. In particular, string values must be surrounded by quotes. To pass these quotes to <code>jj</code>, most shells require surrounding those quotes with single quotes as shown above.</p> <p>In <code>sh</code>-compatible shells, <code>--config-toml</code> can be used to merge entire TOML files with the config specified in <code>.jjconfig.toml</code>:</p> <pre><code>jj --config-toml=\"$(cat extra-config.toml)\" log\n</code></pre>"},{"location":"conflicts.html","title":"First-class conflicts","text":""},{"location":"conflicts.html#introduction","title":"Introduction","text":"<p>Like Pijul and Darcs but unlike most other VCSs, Jujutsu can record conflicted states in commits. For example, if you rebase a commit and it results in a conflict, the conflict will be recorded in the rebased commit and the rebase operation will succeed. You can then resolve the conflict whenever you want. Conflicted states can be further rebased, merged, or backed out. Note that what's stored in the commit is a logical representation of the conflict, not conflict markers; rebasing a conflict doesn't result in a nested conflict markers (see technical doc for how this works).</p>"},{"location":"conflicts.html#advantages","title":"Advantages","text":"<p>The deeper understanding of conflicts has many advantages:</p> <ul> <li>Removes the need for things like   <code>git rebase/merge/cherry-pick/etc --continue</code>. Instead, you get a single   workflow for resolving conflicts: check out the conflicted commit, resolve   conflicts, and amend.</li> <li>Enables the \"auto-rebase\" feature, where descendants of rewritten commits   automatically get rewritten. This feature mostly replaces Mercurial's   Changeset Evolution.</li> <li>Lets us define the change in a merge commit as being compared to the merged   parents. That way, we can rebase merge commits correctly (unlike both Git and   Mercurial). That includes conflict resolutions done in the merge commit,   addressing a common use case for   git rerere.   Since the changes in a merge commit are displayed and rebased as expected,   evil merges   are arguably not as evil anymore.</li> <li>Allows you to postpone conflict resolution until you're ready for it. You   can easily keep all your work-in-progress commits rebased onto upstream's head   if you like.</li> <li>Criss-cross merges   and octopus merges   become trivial (implementation-wise); some cases that Git can't currently   handle, or that would result in nested conflict markers, can be automatically   resolved.</li> <li>Enables collaborative conflict resolution. (This assumes that you can share   the conflicts with others, which you probably shouldn't do if some people   interact with your project using Git.)</li> </ul> <p>For information about how conflicts are handled in the working copy, see here.</p>"},{"location":"conflicts.html#conflict-markers","title":"Conflict markers","text":"<p>Conflicts are \"materialized\" using conflict markers in various contexts. For example, when you run <code>jj edit</code> on a commit with a conflict, it will be materialized in the working copy. Conflicts are also materialized when they are part of diff output (e.g. <code>jj show</code> on a commit that introduces or resolves a conflict). Here's an example of how Git can render a conflict using its \"diff3\" style:</p> <pre><code>  &lt;&lt;&lt;&lt;&lt;&lt;&lt; left\n  apple\n  grapefruit\n  orange\n  ======= base\n  apple\n  grape\n  orange\n  ||||||| right\n  APPLE\n  GRAPE\n  ORANGE\n  &gt;&gt;&gt;&gt;&gt;&gt;&gt;\n</code></pre> <p>In this example, the left side changed \"grape\" to \"grapefruit\", and the right side made all lines uppercase. To resolve the conflict, we would presumably keep the right side (the third section) and replace \"GRAPE\" by \"GRAPEFRUIT\". This way of visually finding the changes between the base and one side and then applying them to the other side is a common way of resolving conflicts when using Git's \"diff3\" style.</p> <p>Jujutsu helps you by combining the base and one side into a unified diff for you, making it easier to spot the differences to apply to the other side. Here's how that would look for the same example as above:</p> <pre><code>  &lt;&lt;&lt;&lt;&lt;&lt;&lt;\n  %%%%%%%\n   apple\n  -grape\n  +grapefruit\n   orange\n  +++++++\n  APPLE\n  GRAPE\n  ORANGE\n  &gt;&gt;&gt;&gt;&gt;&gt;&gt;\n</code></pre> <p>As in Git, the <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> and <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> lines mark the start and end of the conflict. The <code>%%%%%%%</code> line indicates the start of a diff. The <code>+++++++</code> line indicates the start of a snapshot (not a diff).</p> <p>There is another reason for this format (in addition to helping you spot the differences): The format supports more complex conflicts involving more than 3 inputs. Such conflicts can arise when you merge more than 2 commits. They would typically be rendered as a single snapshot (as above) but with more than one unified diffs. The process for resolving them is similar: Manually apply each diff onto the snapshot.</p>"},{"location":"contributing.html","title":"How to Contribute","text":""},{"location":"contributing.html#policies","title":"Policies","text":"<p>We'd love to accept your patches and contributions to this project. There are just a few small guidelines you need to follow.</p>"},{"location":"contributing.html#contributor-license-agreement","title":"Contributor License Agreement","text":"<p>Contributions to this project must be accompanied by a Contributor License Agreement. You (or your employer) retain the copyright to your contribution; this simply gives us permission to use and redistribute your contributions as part of the project. Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one.</p> <p>You generally only need to submit a CLA once, so if you've already submitted one (even if it was for a different project), you probably don't need to do it again.</p>"},{"location":"contributing.html#code-reviews","title":"Code reviews","text":"<p>All submissions, including submissions by project members, require review. We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.</p> <p>Unlike many GitHub projects (but like many VCS projects), we care more about the contents of commits than about the contents of PRs. We review each commit separately, and we don't squash-merge the PR (so please manually squash any fixup commits before sending for review).</p> <p>Each commit should ideally do one thing. For example, if you need to refactor a function in order to add a new feature cleanly, put the refactoring in one commit and the new feature in a different commit. If the refactoring itself consists of many parts, try to separate out those into separate commits. You can use <code>jj split</code> to do it if you didn't realize ahead of time how it should be split up. Include tests and documentation in the same commit as the code the test and document. The commit message should describe the changes in the commit; the PR description can even be empty, but feel free to include a personal message.</p> <p>When you address comments on a PR, don't make the changes in a commit on top (as is typical on GitHub). Instead, please make the changes in the appropriate commit. You can do that by checking out the commit (<code>jj checkout/new &lt;commit&gt;</code>) and then squash in the changes when you're done (<code>jj squash</code>). <code>jj git push</code> will automatically force-push the branch.</p> <p>When your first PR has been approved, we typically give you contributor access, so you can address any remaining minor comments and then merge the PR yourself when you're ready. If you realize that some comments require non-trivial changes, please ask your reviewer to take another look.</p>"},{"location":"contributing.html#community-guidelines","title":"Community Guidelines","text":"<p>This project follows Google's Open Source Community Guidelines.</p>"},{"location":"contributing.html#contributing-to-the-documentation","title":"Contributing to the documentation","text":"<p>We appreciate bug reports about any problems, however small, lurking in our documentation website or in the <code>jj help &lt;command&gt;</code> docs. If a part of the bug report template does not apply, you can just delete it.</p> <p>Before reporting a problem with the documentation website, we'd appreciate it if you could check that the problem still exists in the \"prerelease\" version of the documentation (as opposed to the docs for one of the released versions of <code>jj</code>). You can use the version switcher in the top-left of the website to do so.</p> <p>If you are willing to make a PR fixing a documentation problem, even better!</p> <p>The documentation website sources are Markdown files located in the <code>docs/</code> directory. You do not need to know Rust to work with them. See below for instructions on how to preview the HTML docs as you edit the Markdown files. Doing so is optional, but recommended.</p> <p>The <code>jj help</code> docs are sourced from the \"docstring\" comments inside the Rust sources, currently from the <code>cli/src/commands</code> directory. Working on them requires setting up a Rust development environment, as described below, and may occasionally require adjusting a test.</p>"},{"location":"contributing.html#learning-rust","title":"Learning Rust","text":"<p>In addition to the Rust Book and the other excellent resources at https://www.rust-lang.org/learn, we recommend the \"Comprehensive Rust\" mini-course for an overview, especially if you are familiar with C++.</p>"},{"location":"contributing.html#setting-up-a-development-environment","title":"Setting up a development environment","text":"<p>To develop <code>jj</code>, the mandatory steps are simply to install Rust (the default installer options are fine), clone the repository, and use <code>cargo build</code> , <code>cargo fmt</code>, <code>cargo clippy --workspace --all-targets</code>, and <code>cargo test --workspace</code>. If you are preparing a PR, there are some additional recommended steps.</p>"},{"location":"contributing.html#summary","title":"Summary","text":"<p>One-time setup:</p> <pre><code>rustup toolchain add nightly  # wanted for 'rustfmt'\nrustup toolchain add 1.71     # also specified in Cargo.toml\ncargo install cargo-insta\ncargo install cargo-watch\ncargo install cargo-nextest\n</code></pre> <p>During development (adapt according to your preference):</p> <pre><code>cargo watch --ignore '.jj/**' -s \\\n  'cargo clippy --workspace --all-targets \\\n   &amp;&amp; cargo +1.71 check --workspace --all-targets'\ncargo +nightly fmt # Occasionally\ncargo nextest run --workspace # Occasionally\ncargo insta test --workspace --test-runner nextest # Occasionally\n</code></pre> <p>WARNING: Build artifacts from debug builds and especially from repeated invocations of <code>cargo test</code> can quickly take up 10s of GB of disk space. Cargo will happily use up your entire hard drive. If this happens, run <code>cargo clean</code>.</p>"},{"location":"contributing.html#explanation","title":"Explanation","text":"<p>These are listed roughly in order of decreasing importance.</p> <ol> <li> <p>Nearly any change to <code>jj</code>'s CLI will require writing or updating snapshot    tests that use the <code>insta</code> crate. To make this    convenient, install the <code>cargo-insta</code> binary.    Use <code>cargo insta test --workspace</code> to run tests,    and <code>cargo insta review --workspace</code> to update the snapshot tests.    The <code>--workspace</code> flag is needed to run the tests on all crates; by default,    only the crate in the current directory is tested.</p> </li> <li> <p>GitHub CI checks require that the code is formatted with the nightly    version of <code>rustfmt</code>. To do this on your computer, install the nightly    toolchain and use <code>cargo +nightly fmt</code>.</p> </li> <li> <p>Your code will be rejected if it cannot be compiled with the minimal    supported version of Rust (\"MSRV\"). Currently, <code>jj</code> follows a rather    casual MSRV policy: \"The current <code>rustc</code> stable version, minus one.\"    As of this writing, that version is 1.71.0.</p> </li> <li> <p>Your code needs to pass <code>cargo clippy</code>. You can also    use <code>cargo +nightly clippy</code> if you wish to see more warnings.</p> </li> <li> <p>You may also want to install and use <code>cargo-watch</code>. In this case, you should    exclude <code>.jj</code>. directory from the filesystem watcher, as it gets updated on    every <code>jj log</code>.</p> </li> <li> <p>To run tests more quickly, use <code>cargo nextest run --workspace</code>. To    use <code>nextest</code> with <code>insta</code>,    use <code>cargo insta test --workspace --test-runner nextest</code>.</p> </li> </ol>"},{"location":"contributing.html#previewing-the-html-documentation","title":"Previewing the HTML documentation","text":"<p>The documentation for <code>jj</code> is automatically published to the website at https://martinvonz.github.io/jj/.</p> <p>When editing documentation, we'd appreciate it if you checked that the result will look as expected when published to the website.</p>"},{"location":"contributing.html#setting-up-the-prerequisites","title":"Setting up the prerequisites","text":"<p>To build the website, you must have Python and <code>poetry</code> installed. If your distribution packages <code>poetry</code>, something like <code>apt install python3-poetry</code> is likely the best way to install it. Otherwise, you can download Python from https://python.org or follow the Python installation instructions. Finally, follow the Poetry installation instructions.</p> <p>Once you have <code>poetry</code> installed, you should ask it to install the rest of the required tools into a virtual environment as follows:</p> <pre><code>poetry install\n</code></pre> <p>If you get requests to \"unlock a keyring\" or error messages about failing to do so, this is a known <code>poetry</code> bug. The workaround is to run the following and then to try <code>poetry install</code> again:</p> <pre><code># For sh-compatible shells or recent versions of `fish`\nexport PYTHON_KEYRING_BACKEND=keyring.backends.fail.Keyring\n</code></pre>"},{"location":"contributing.html#building-the-html-docs-locally-with-live-reload","title":"Building the HTML docs locally (with live reload)","text":"<p>The HTML docs are built with MkDocs. After following the above steps, you should be able to view the docs by running</p> <pre><code># Note: this and all the commands below should be run from the root of\n# the `jj` source tree.\npoetry run -- mkdocs serve\n</code></pre> <p>and opening http://127.0.0.1:8000 in your browser.</p> <p>As you edit the <code>md</code> files, the website should be rebuilt and reloaded in your browser automatically, unless build errors occur.</p> <p>You should occasionally check the terminal from which you ran <code>mkdocs serve</code> for any build errors or warnings. Warnings about <code>\"GET /versions.json HTTP/1.1\" code 404</code> are expected and harmless.</p>"},{"location":"contributing.html#how-to-build-the-entire-website-not-usually-necessary","title":"How to build the entire website (not usually necessary)","text":"<p>The full <code>jj</code> website includes the documentation for several <code>jj</code> versions (<code>prerelease</code>, latest release, and the older releases). The top-level URL https://martinvonz.github.io/jj redirects to https://martinvonz.github.io/jj/latest, which in turn redirects to the docs for the last stable version.</p> <p>The different versions of documentation are managed and deployed with <code>mike</code>, which can be run with <code>poetry run -- mike</code>.</p> <p>On a POSIX system or WSL, one way to build the entire website is as follows (on Windows, you'll need to understand and adapt the shell script):</p> <ol> <li> <p>Check out <code>jj</code> as a co-located <code>jj + git</code> repository (<code>jj clone --colocate</code>), cloned from your fork of <code>jj</code> (e.g. <code>jjfan.github.com/jj</code>). You can also use a pure Git repo if you prefer.</p> </li> <li> <p>Make sure <code>jjfan.github.com/jj</code> includes the <code>gh-pages</code> branch of the jj repo and run <code>git fetch origin gh-pages</code>.</p> </li> <li> <p>Go to the GitHub repository settings, enable GitHub Pages, and configure them to use the <code>gh-pages</code> branch (this is usually the default).</p> </li> <li> <p>Run the same <code>sh</code> script that is used in GitHub CI (details below):</p> <pre><code>.github/scripts/docs-build-deploy 'https://jjfan.github.io/jj/'\\\nprerelease main --push\n</code></pre> <p>This should build the version of the docs from the current commit, deploy it as a new commit to the <code>gh-pages</code> branch, and push the <code>gh-pages</code> branch to the origin.</p> </li> <li> <p>Now, you should be able to see the full website, including your latest changes to the <code>prerelease</code> version, at <code>https://jjfan.github.io/jj/prerelease/</code>.</p> </li> <li> <p>(Optional) The previous steps actually only rebuild <code>https://jjfan.github.io/jj/prerelease/</code> and its alias <code>https://jjfan.github.io/jj/main/</code>. If you'd like to test out version switching back and forth, you can also rebuild the docs for the latest release as follows.</p> <pre><code>jj new v1.33.1  # Let's say `jj 1.33.1` is the currently the latest release\n.github/scripts/docs-build-deploy 'https://jjfan.github.io/jj/'\\\nv1.33.1 latest --push\n</code></pre> </li> <li> <p>(Optional) When you are done, you may want to reset the <code>gh-branches</code> to the same spot as it is in the upstream. If you configured the <code>upstream</code> remote, this can be done with:</p> <pre><code># This will LOSE any changes you made to `gh-pages`\njj git fetch --remote upstream\njj branch set gh-pages -r gh-pages@upstream\njj git push --remote origin --branch gh-pages\n</code></pre> <p>If you want to preserve some of the changes you made, you can do <code>jj branch set my-changes -r gh-pages</code> BEFORE running the above commands.</p> </li> </ol>"},{"location":"contributing.html#explanation-of-the-docs-build-deploy-script","title":"Explanation of the <code>docs-build-deploy</code> script","text":"<p>The script sets up the <code>site_url</code> mkdocs config to <code>'https://jjfan.github.io/jj/'</code>. If this config does not match the URL where you loaded the website, some minor website features (like the version switching widget) will have reduced functionality.</p> <p>Then, the script passes the rest of its arguments to <code>potery run -- mike deploy</code>, which does the rest of the job. Run <code>poetry run -- mike help deploy</code> to find out what the arguments do.</p> <p>If you need to do something more complicated, you can use <code>poetry run -- mike ...</code> commands. You can also edit the <code>gh-pages</code> branch directly, but take care to avoid files that will be overwritten by future invocations of <code>mike</code>. Then, you can submit a PR based on the <code>gh-pages</code> branch of https://martinvonz.github.com/jj (instead of the usual <code>main</code> branch).</p>"},{"location":"contributing.html#modifying-protobuffers-this-is-not-common","title":"Modifying protobuffers (this is not common)","text":"<p>Occasionally, you may need to change the <code>.proto</code> files that define jj's data  storage format. In this case, you will need to add a few steps to the above  workflow.</p> <ul> <li>Install the <code>protoc</code> compiler. This usually means either <code>apt-get install    protobuf-compiler</code> or downloading an official release. The    <code>prost</code> library docs have additional advice.</li> <li>Run <code>cargo run -p gen-protos</code> regularly (or after every edit to a <code>.proto</code>    file). This is the same as running <code>cargo run</code> from <code>lib/gen-protos</code>. The    <code>gen-protos</code> binary will use the <code>prost-build</code> library to compile the    <code>.proto</code> files into <code>.rs</code> files.</li> <li>If you are adding a new <code>.proto</code> file, you will need to edit the list of    these files in <code>lib/gen-protos/src/main.rs</code>.</li> </ul> <p>The <code>.rs</code> files generated from <code>.proto</code> files are included in the repository,  and there is a GitHub CI check that will complain if they do not match.</p>"},{"location":"git-comparison.html","title":"Comparison with Git","text":""},{"location":"git-comparison.html#introduction","title":"Introduction","text":"<p>This document attempts to describe how Jujutsu is different from Git. See the Git-compatibility doc for information about how the <code>jj</code> command interoperates with Git repos.</p>"},{"location":"git-comparison.html#overview","title":"Overview","text":"<p>Here is a list of conceptual differences between Jujutsu and Git, along with links to more details where applicable and available. There's a table further down explaining how to achieve various use cases.</p> <ul> <li>The working copy is automatically committed. That results in a simpler and   more consistent CLI because the working copy is now treated like any other   commit. Details.</li> <li>There's no index (staging area). That also results in a simpler   CLI for similar reasons. The index is very similar to an intermediate commit   between <code>HEAD</code> and the working copy, so workflows that depend on it can be   modeled using proper commits instead. Details.</li> <li>No need for branch names. Git lets you check out a commit without   attaching a branch. It calls this state \"detached HEAD\". This is the normal   state in Jujutsu (there's actually no way -- yet, at least -- to have an   active branch). However, Jujutsu keeps track of all visible heads (leaves) of   the commit graph, so the commits won't get lost or garbage-collected.</li> <li>No current branch. Git lets you check out a branch, making it the 'current   branch', and new commits will automatically update the branch. This is   necessary in Git because Git might otherwise lose track of the new commits.   Jujutsu does not have a 'current branch'; instead, you update branches   manually. For example, if you check out a commit with a branch, new commits   are created on top of the branch, then you issue a later command to update the   branch.</li> <li>Conflicts can be committed. No commands fail because of merge conflicts.   The conflicts are instead recorded in commits and you can resolve them later.   Details.</li> <li>Descendant commits are automatically rebased. Whenever you rewrite a   commit (e.g. by running <code>jj rebase</code>), all its descendants commits will   automatically be rebased on top. Branches pointing to it will also get   updated, and so will the working copy if it points to any of the rebased   commits.</li> <li>Branches are identified by their names (across remotes). For example, if   you pull from a remote that has a <code>main</code> branch, you'll get a branch by that   name in your local repo as well. If you then move it and push back to the   remote, the <code>main</code> branch on the remote will be updated.  Details.</li> <li>The operation log replaces reflogs. The operation log is similar to   reflogs, but is much more powerful. It keeps track of atomic updates to all   refs at once (Jujutsu thus improves on Git's per-ref history much in the same   way that Subversion improved on RCS's per-file history). The operation log   powers e.g. the undo functionality. Details</li> <li>There's a single, virtual root commit. Like Mercurial, Jujutsu has a   virtual commit (with a hash consisting of only zeros) called the \"root commit\"   (called the \"null revision\" in Mercurial). This commit is a common ancestor of   all commits. That removes the awkward state Git calls the \"unborn branch\"   state (which is the state a newly initialized Git repo is in), and related   command-line flags (e.g. <code>git rebase --root</code>, <code>git checkout --orphan</code>).</li> </ul>"},{"location":"git-comparison.html#the-index","title":"The index","text":"<p>Git's \"index\" has multiple roles. One role is as a cache of file system information. Jujutsu has something similar. Unfortunately, Git exposes the index to the user, which makes the CLI unnecessarily complicated (learning what the different flavors of <code>git reset</code> do, especially when combined with commits and/or paths, usually takes a while). Jujutsu, like Mercurial, doesn't make that mistake.</p> <p>As a Git power-user, you may think that you need the power of the index to commit only part of the working copy. However, Jujutsu provides commands for more directly achieving most use cases you're used to using Git's index for. For example, to create a commit from part of the changes in the working copy, you might be used to using <code>git add -p; git commit</code>. With Jujutsu, you'd instead use <code>jj split</code> to split the working-copy commit into two commits. To add more changes into the parent commit, which you might normally use <code>git add -p; git commit --amend</code> for, you can instead use <code>jj squash -i</code> to choose which changes to move into the parent commit, or <code>jj squash &lt;file&gt;</code> to move a specific file.</p>"},{"location":"git-comparison.html#command-equivalence-table","title":"Command equivalence table","text":"<p>Note that all <code>jj</code> commands can be run on any commit (not just the working-copy commit), but that's left out of the table to keep it simple. For example, <code>jj squash/amend -r &lt;revision&gt;</code> will move the diff from that revision into its parent.</p> Use case Jujutsu command Git command Create a new repo <code>jj init --git</code> (without <code>--git</code>, you get a           native Jujutsu repo, which is slow and whose format will change) <code>git init</code> Clone an existing repo <code>jj git clone &lt;source&gt; &lt;destination&gt;</code> (there is no support           for cloning non-Git repos yet) <code>git clone &lt;source&gt; &lt;destination&gt;</code> Update the local repo with all branches from a remote <code>jj git fetch [--remote &lt;remote&gt;]</code> (there is no           support for fetching into non-Git repos yet) <code>git fetch [&lt;remote&gt;]</code> Update a remote repo with all branches from the local repo <code>jj git push --all [--remote &lt;remote&gt;]</code> (there is no           support for pushing from non-Git repos yet) <code>git push --all [&lt;remote&gt;]</code> Update a remote repo with a single branch from the local repo <code>jj git push --branch &lt;branch name&gt;                 [--remote &lt;remote&gt;]</code> (there is no support for                 pushing from non-Git repos yet) <code>git push &lt;remote&gt; &lt;branch name&gt;</code> Show summary of current work and repo status <code>jj st</code> <code>git status</code> Show diff of the current change <code>jj diff</code> <code>git diff HEAD</code> Show diff of another change <code>jj diff -r &lt;revision&gt;</code> <code>git diff &lt;revision&gt;^ &lt;revision&gt;</code> Show diff from another change to the current change <code>jj diff --from &lt;revision&gt;</code> <code>git diff &lt;revision&gt;</code> Show diff from change A to change B <code>jj diff --from A --to B</code> <code>git diff A B</code> Show description and diff of a change <code>jj show &lt;revision&gt;</code> <code>git show &lt;revision&gt;</code> Add a file to the current change <code>touch filename</code> <code>touch filename; git add filename</code> Remove a file from the current change <code>rm filename</code> <code>git rm filename</code> Modify a file in the current change <code>echo stuff &gt;&gt; filename</code> <code>echo stuff &gt;&gt; filename</code> Finish work on the current change and start a new change <code>jj commit</code> <code>git commit -a</code> See log of commits <code>jj log</code> <code>git log --oneline --graph --decorate</code> Abandon the current change and start a new change <code>jj abandon</code> <code>git reset --hard</code> (cannot be undone) Make the current change empty <code>jj restore</code> <code>git reset --hard</code> (same as abandoning a change since Git           has no concept of a \"change\") Discard working copy changes in some files <code>jj restore &lt;paths&gt;...</code> <code>git restore &lt;paths&gt;...</code> or <code>git checkout HEAD -- &lt;paths&gt;...</code> Edit description (commit message) of the current change <code>jj describe</code> Not supported Edit description (commit message) of the previous change <code>jj describe @-</code> <code>git commit --amend</code> (first make sure that nothing is           staged) Temporarily put away the current change Not needed <code>git stash</code> Start working on a new change based on the &lt;main&gt; branch <code>jj co main</code> <code>git switch -c topic main</code> or         <code>git checkout -b topic main</code> (may need to stash or commit         first) Move branch A onto branch B <code>jj rebase -b A -d B</code> <code>git rebase B A</code>           (may need to rebase other descendant branches separately) Move change A and its descendants onto change B <code>jj rebase -s A -d B</code> <code>git rebase --onto B A^ &lt;some descendant branch&gt;</code>           (may need to rebase other descendant branches separately) Reorder changes from A-B-C-D to A-C-B-D <code>jj rebase -r C -d A; rebase -s B -d C</code> (pass change IDs,           not commit IDs, to not have to look up commit ID of rewritten C) <code>git rebase -i A</code> Move the diff in the current change into the parent change <code>jj squash/amend</code> <code>git commit --amend -a</code> Interactively move part of the diff in the current change into the           parent change <code>jj squash/amend -i</code> <code>git add -p; git commit --amend</code> Move the diff in the working copy into an ancestor <code>jj move --to X</code> <code>git commit --fixup=X; git rebase -i --autosquash X^</code> Interactively move part of the diff in an arbitrary change to another           arbitrary change <code>jj move -i --from X --to Y</code> Not supported Interactively split the changes in the working copy in two <code>jj split</code> <code>git commit -p</code> Interactively split an arbitrary change in two <code>jj split -r &lt;revision&gt;</code> Not supported (can be emulated with the \"edit\" action in           <code>git rebase -i</code>) Interactively edit the diff in a given change <code>jj diffedit -r &lt;revision&gt;</code> Not supported (can be emulated with the \"edit\" action in           <code>git rebase -i</code>) Resolve conflicts and continue interrupted operation <code>echo resolved &gt; filename; jj squash/amend</code> (operations           don't get interrupted, so no need to continue) <code>echo resolved &gt; filename; git add filename; git           rebase/merge/cherry-pick --continue</code> Create a copy of a commit on top of another commit <code>jj duplicate &lt;source&gt;; jj rebase -r &lt;duplicate commit&gt; -d &lt;destination&gt;</code>           (there's no single command for it yet) <code>git co &lt;destination&gt;; git cherry-pick &lt;source&gt;</code> List branches <code>jj branch list</code> <code>git branch</code> Create a branch <code>jj branch create &lt;name&gt; -r &lt;revision&gt;</code> <code>git branch &lt;name&gt; &lt;revision&gt;</code> Move a branch forward <code>jj branch set &lt;name&gt; -r &lt;revision&gt;</code> <code>git branch -f &lt;name&gt; &lt;revision&gt;</code> Move a branch backward or sideways <code>jj branch set &lt;name&gt; -r &lt;revision&gt; --allow-backwards</code> <code>git branch -f &lt;name&gt; &lt;revision&gt;</code> Delete a branch <code>jj branch delete &lt;name&gt; </code> <code>git branch --delete &lt;name&gt;</code> See log of operations performed on the repo <code>jj op log</code> Not supported Undo an earlier operation <code>jj [op] undo &lt;operation ID&gt;</code>           (<code>jj undo</code> is an alias for <code>jj op undo</code>)        Not supported"},{"location":"git-compatibility.html","title":"Git compatibility","text":"<p>Jujutsu has two backends for storing commits. One of them uses a regular Git repo, which means that you can collaborate with Git users without them even knowing that you're not using the <code>git</code> CLI.</p> <p>See <code>jj help git</code> for help about the <code>jj git</code> family of commands, and e.g. <code>jj help git push</code> for help about a specific command (use <code>jj git push -h</code> for briefer help).</p>"},{"location":"git-compatibility.html#supported-features","title":"Supported features","text":"<p>The following list describes which Git features Jujutsu is compatible with. For a comparison with Git, including how workflows are different, see the Git-comparison doc.</p> <ul> <li>Configuration: Partial. The only configuration from Git (e.g. in   <code>~/.gitconfig</code>) that's respected is the following. Feel free to file a bug if   you miss any particular configuration options.</li> <li>The configuration of remotes (<code>[remote \"&lt;name&gt;\"]</code>).</li> <li><code>core.excludesFile</code></li> <li>Authentication: Partial. Only <code>ssh-agent</code>, a password-less key (   only <code>~/.ssh/id_rsa</code>, <code>~/.ssh/id_ed25519</code> or <code>~/.ssh/id_ed25519_sk</code>), or   a <code>credential.helper</code>.</li> <li>Branches: Yes. You can read more about   how branches work in Jujutsu   and how they interoperate with Git.</li> <li>Tags: Partial. You can check out tagged commits by name (pointed to be   either annotated or lightweight tags), but you cannot create new tags.</li> <li>.gitignore: Yes. Ignores in <code>.gitignore</code> files are supported. So are   ignores in <code>.git/info/exclude</code> or configured via Git's <code>core.excludesfile</code>   config. The <code>.gitignore</code> support uses a native implementation, so please   report a bug if you notice any difference compared to <code>git</code>.  </li> <li>.gitattributes: No. There's #53   about adding support for at least the <code>eol</code> attribute.</li> <li>Hooks: No. There's #405   specifically for providing the checks from https://pre-commit.com.</li> <li>Merge commits: Yes. Octopus merges (i.e. with more than 2 parents) are   also supported.</li> <li>Detached HEAD: Yes. Jujutsu supports anonymous branches, so this is a   natural state.</li> <li>Orphan branch: Yes. Jujutsu has a virtual root commit that appears as   parent of all commits Git would call \"root commits\".</li> <li>Staging area: Kind of. The staging area will be ignored. For example,   <code>jj diff</code> will show a diff from the Git HEAD to the working copy. There are   ways of fulfilling your use cases without a staging   area.  </li> <li>Garbage collection: Yes. It should be safe to run <code>git gc</code> in the Git   repo, but it's not tested, so it's probably a good idea to make a backup of   the whole workspace first. There's no garbage collection and repacking of   Jujutsu's own data structures yet,   however.</li> <li>Bare repositories: Yes. You can use <code>jj init --git-repo=&lt;path&gt;</code> to create   a repo backed by a bare Git repo.</li> <li>Submodules: No. They will not show up in the working copy, but they will   not be lost either.</li> <li>Partial clones: No. We use the libgit2 library,   which doesn't have support for partial clones.</li> <li>Shallow clones: No. We use the libgit2 library,   which doesn't have support for shallow clones.</li> <li>git-worktree: No. However, there's native support for multiple working   copies backed by a single repo. See the <code>jj workspace</code> family of commands.</li> <li>Sparse checkouts: No. However, there's native support for sparse   checkouts. See the <code>jj sparse</code> command.</li> <li>Signed commits: No. (#58)</li> <li>Git LFS: No. (#80)</li> </ul>"},{"location":"git-compatibility.html#creating-an-empty-repo","title":"Creating an empty repo","text":"<p>To create an empty repo using the Git backend, use <code>jj init --git &lt;name&gt;</code>. Since the command creates a Jujutsu repo, it will have a <code>.jj/</code> directory. The underlying Git repo will be inside of that directory (currently in <code>.jj/repo/store/git/</code>).</p>"},{"location":"git-compatibility.html#creating-a-repo-backed-by-an-existing-git-repo","title":"Creating a repo backed by an existing Git repo","text":"<p>To create a Jujutsu repo backed by a Git repo you already have on disk, use <code>jj init --git-repo=&lt;path to Git repo&gt; &lt;name&gt;</code>. The repo will work similar to a Git worktree, meaning that the working copies files and the record of the working-copy commit will be separate, but the commits will be accessible in both repos. Use <code>jj git import</code> to update the Jujutsu repo with changes made in the Git repo. Use <code>jj git export</code> to update the Git repo with changes made in the Jujutsu repo.</p>"},{"location":"git-compatibility.html#creating-a-repo-by-cloning-a-git-repo","title":"Creating a repo by cloning a Git repo","text":"<p>To create a Jujutsu repo from a remote Git URL, use <code>jj git clone &lt;URL&gt; [&lt;destination&gt;]</code>. For example, <code>jj git clone https://github.com/octocat/Hello-World</code> will clone GitHub's \"Hello-World\" repo into a directory by the same name.</p>"},{"location":"git-compatibility.html#co-located-jujutsugit-repos","title":"Co-located Jujutsu/Git repos","text":"<p>A \"co-located\" Jujutsu repo is a hybrid Jujutsu/Git repo. These can be created if you initialize the Jujutsu repo in an existing Git repo by running <code>jj init --git-repo=.</code> or with <code>jj git clone --colocate</code>. The Git repo and the Jujutsu repo then share the same working copy. Jujutsu will import and export from and to the Git repo on every <code>jj</code> command automatically.</p> <p>This mode is very convenient when tools (e.g. build tools) expect a Git repo to be present.</p> <p>It is allowed to mix <code>jj</code> and <code>git</code> commands in such a repo in any order. However, it may be easier to keep track of what is going on if you mostly use read-only <code>git</code> commands and use <code>jj</code> to make changes to the repo. One reason for this (see below for more) is that <code>jj</code> commands will usually put the git repo in a \"detached HEAD\" state, since in <code>jj</code> there is not concept of a \"currently tracked branch\". Before doing mutating Git commands, you may need to tell Git what the current branch should be with a <code>git switch</code> command.</p> <p>You can undo the results of mutating <code>git</code> commands using <code>jj undo</code> and <code>jj op restore</code>. Inside <code>jj op log</code>, changes by <code>git</code> will be represented as an \"import git refs\" operation.</p> <p>There are a few downsides to this mode of operation. Generally, using co-located repos may require you to deal with more involved Jujutsu and Git concepts.</p> <ul> <li> <p>Interleaving <code>jj</code> and <code>git</code> commands increases the chance of confusing branch   conflicts or conflicted (AKA divergent) change   ids. These never lose data, but can be   annoying.</p> <p>Such interleaving can happen unknowingly. For example, some IDEs can cause   it because they automatically run <code>git fetch</code> in the background from time to   time.</p> </li> <li> <p>Git tools will have trouble with revisions that contain conflicted files. While   <code>jj</code> renders these files with conflict markers in the working copy, they are   stored in a non-human-readable fashion inside the repo. Git tools will often   see this non-human-readable representation.</p> </li> <li> <p>When a <code>jj</code> branch is conflicted, the position of the branch in the Git repo   will disagree with one or more of the conflicted positions. The state of that   branch in git will be labeled as though it belongs to a remote named \"git\",   e.g. <code>branch@git</code>.</p> </li> <li> <p>Jujutsu will ignore Git's staging area. It will not understand merge conflicts   as Git represents them, unfinished <code>git rebase</code> states, as well as other less   common states a Git repository can be in.</p> </li> <li> <p>Colocated repositories are less resilient to   concurrency   issues if you share the repo using an NFS filesystem or Dropbox. In general,   such use of Jujutsu is not currently thoroughly tested.</p> </li> <li> <p>There may still be bugs when interleaving mutating <code>jj</code> and <code>git</code> commands,   usually having to do with a branch pointer ending up in the wrong place. We   are working on the known ones, and are not aware of any major ones. Please   report any new ones you find, or if any of the known bugs are less minor than   they appear.</p> </li> </ul>"},{"location":"git-compatibility.html#branches","title":"Branches","text":"<p>TODO: Describe how branches are mapped</p>"},{"location":"git-compatibility.html#format-mapping-details","title":"Format mapping details","text":"<p>Paths are assumed to be UTF-8. I have no current plans to support paths with other encodings.</p> <p>Commits created by <code>jj</code> have a ref starting with <code>refs/jj/</code> to prevent GC.</p> <p>Commit metadata that cannot be represented in Git commits (such as the Change ID) is stored outside of the Git repo (currently in <code>.jj/store/extra/</code>).</p> <p>Paths with conflicts cannot be represented in Git. They appear as files with a <code>.jjconflict</code> suffix in the Git repo. They contain a JSON representation with information about the conflict. They are not meant to be human-readable.</p>"},{"location":"github.html","title":"Using Jujutsu with GitHub and GitLab Projects","text":"<p>This guide assumes a basic understanding of either Git or Mercurial.</p>"},{"location":"github.html#set-up-an-ssh-key","title":"Set up an SSH key","text":"<p>As of December 2022 it's recommended to set up an SSH key to work with GitHub projects. See GitHub's Tutorial. This restriction may be lifted in the future, see issue #469 for more information and progress on authenticated http.</p>"},{"location":"github.html#basic-workflow","title":"Basic workflow","text":"<p>The simplest way to start with Jujutsu, is creating a stack of commits, before creating any branch.</p> <pre><code># Start a new commit off of `main`\n$ jj new main\n# Refactor some files, then add a description and start a new commit\n$ jj commit -m 'refactor(foo): restructure foo()'\n# Add a feature, then add a description and start a new commit\n$ jj commit -m 'feat(bar): add support for bar'\n# Create a branch so we can push it to GitHub\n$ jj branch create bar -r @-\n# Push the branch to GitHub (pushes only `bar`)\n$ jj git push\n</code></pre> <p>While it's possible to create a branch and commit on top of it in a Git like manner, it's not recommended, as no further commits will be placed on the branch.</p>"},{"location":"github.html#updating-the-repository","title":"Updating the repository.","text":"<p>As of December 2022, Jujutsu has no equivalent to a <code>git pull</code> command. Until such a command is added, you need to use <code>jj git fetch</code> followed by a <code>jj rebase -d $main_branch</code> to update your changes.</p>"},{"location":"github.html#working-in-a-git-co-located-repository","title":"Working in a Git co-located repository","text":"<p>After doing <code>jj init --git-repo=.</code>, git will be in a detached HEAD state, which is unusual, as git mainly works with branches. In a co-located repository, <code>jj</code> isn't the source of truth. But Jujutsu allows an incremental migration, as <code>jj commit</code> updates the HEAD of the git repository.</p> <pre><code>$ nvim docs/tutorial.md\n$ # Do some more work.\n$ jj commit -m \"Update tutorial\"\n$ jj branch create doc-update\n$ # Move the previous revision to doc-update.\n$ jj branch set doc-update -r @-\n$ jj git push\n</code></pre>"},{"location":"github.html#working-in-a-jujutsu-repository","title":"Working in a Jujutsu repository","text":"<p>In a Jujutsu repository, the workflow is simplified. If there's no need for explicitly named branches, you just can generate one for a change. As Jujutsu is able to create a branch for a revision.</p> <pre><code>$ # Do your work\n$ jj commit\n$ # Jujutsu automatically creates a branch\n$ jj git push --change $revision\n</code></pre>"},{"location":"github.html#addressing-review-comments","title":"Addressing review comments","text":"<p>There are two workflows for addressing review comments, depending on your project's preference. Many projects prefer that you address comments by adding commits to your branch<sup>1</sup>. Some projects (such as Jujutsu and LLVM) instead prefer that you keep your commits clean by rewriting them and then force-pushing<sup>2</sup>.</p>"},{"location":"github.html#adding-new-commits","title":"Adding new commits","text":"<p>If your project prefers that you address review comments by adding commits on top, you can do that by doing something like this:</p> <pre><code>$ # Create a new commit on top of the `your-feature` branch from above.\n$ jj new your-feature\n$ # Address the comments, by updating the code\n$ jj diff\n$ # Give the fix a description and create a new working-copy on top.\n$ jj commit -m 'address pr comments'\n$ # Update the branch to point to the new commit.\n$ jj branch set your-feature -r @-\n$ # Push it to your remote\n$ jj git push.\n</code></pre>"},{"location":"github.html#rewriting-commits","title":"Rewriting commits","text":"<p>If your project prefers that you keep commits clean, you can do that by doing something like this:</p> <pre><code>$ # Create a new commit on top of the second-to-last commit in `your-feature`,\n$ # as reviews requested a fix there.\n$ jj new your-feature-\n$ # Address the comments by updating the code\n$ # Review the changes\n$ jj diff\n$ # Squash the changes into the parent commit\n$ jj squash\n$ # Push the updated branch to the remote. Jujutsu automatically makes it a force push\n$ jj git push --branch your-feature\n</code></pre>"},{"location":"github.html#using-github-cli","title":"Using GitHub CLI","text":"<p>GitHub CLI will have trouble finding the proper git repository path in jj repos that aren't co-located (see issue #1008). You can configure the <code>$GIT_DIR</code> environment variable to point it to the right path:</p> <pre><code>$ GIT_DIR=.jj/repo/store/git gh issue list\n</code></pre> <p>You can make that automatic by installing direnv and defining hooks in a .envrc file in the repository root to configure <code>$GIT_DIR</code>. Just add this line into .envrc:</p> <pre><code>export GIT_DIR=$PWD/.jj/repo/store/git\n</code></pre> <p>and run <code>direnv allow</code> to approve it for direnv to run. Then GitHub CLI will work automatically even in repos that aren't co-located so you can execute commands like <code>gh issue list</code> normally.</p>"},{"location":"github.html#useful-revsets","title":"Useful Revsets","text":"<p>Log all revisions across all local branches, which aren't on the main branch nor on any remote <code>jj log -r 'branches() &amp; ~(main | remote_branches())'</code> Log all revisions which you authored, across all branches which aren't on any remote <code>jj log -r 'mine() &amp; branches() &amp; ~remote_branches()'</code> Log all remote branches, which you authored or committed to <code>jj log -r 'remote_branches() &amp; (mine() | committer(your@email.com))'</code> Log all descendants of the current working copy, which aren't on a remote <code>jj log -r '::@ &amp; ~remote_branches()'</code></p>"},{"location":"github.html#merge-conflicts","title":"Merge conflicts","text":"<p>For a detailed overview, how Jujutsu handles conflicts, revisit the tutorial.</p>"},{"location":"github.html#using-several-remotes","title":"Using several remotes","text":"<p>It is common to use several remotes when contributing to a shared repository. For example, \"upstream\" can designate the remote where the changes will be merged through a pull-request while \"origin\" is your private fork of the project. In this case, you might want to <code>jj git fetch</code> from \"upstream\" and to <code>jj git push</code> to \"origin\".</p> <p>You can configure the default remotes to fetch from and push to in your configuration file (for example <code>.jj/repo/config.toml</code>):</p> <pre><code>[git]\nfetch = \"upstream\"\npush = \"origin\"\n</code></pre> <p>The default for both <code>git.fetch</code> and <code>git.push</code> is \"origin\".</p> <ol> <li> <p>This is a GitHub Style review, as GitHub currently only is able to compare branches.\u00a0\u21a9</p> </li> <li> <p>If you're wondering why we prefer clean commits in this project, see e.g. this blog post \u21a9</p> </li> </ol>"},{"location":"glossary.html","title":"Glossary","text":""},{"location":"glossary.html#anonymous-branch","title":"Anonymous branch","text":"<p>An anonymous branch is a chain of commits that doesn't have any named branches pointing to it or to any of its descendants. Unlike Git, Jujutsu keeps commits on anonymous branches around until they are explicitly abandoned. Visible anonymous branches are tracked by the view, which stores a list of heads of such branches.</p>"},{"location":"glossary.html#backend","title":"Backend","text":"<p>A backend is an implementation of the storage layer. There are currently two builtin commit backends: the Git backend and the native backend. The Git backend stores commits in a Git repository. The native backend is used for testing purposes only. Alternative backends could be used, for example, if somebody wanted to use jj with a humongous monorepo (as Google does).</p> <p>There are also pluggable backends for storing other information than commits, such as the \"operation store backend\" for storing the operation log.</p>"},{"location":"glossary.html#branch","title":"Branch","text":"<p>A branch is a named pointer to a commit. They automatically follow the commit if it gets rewritten. Branches are sometimes called \"named branches\" to distinguish them from anonymous branches, but note that they are more similar to Git's branches than to Mercurial's named branches. See here for details.</p>"},{"location":"glossary.html#change","title":"Change","text":"<p>A change is a commit as it evolves over time.</p>"},{"location":"glossary.html#change-id","title":"Change ID","text":"<p>A change ID is a unique identifier for a change. They are typically 16 bytes long and are often randomly generated. By default, <code>jj log</code> presents them as a sequence of 12 letters in the k-z range, at the beginning of a line. These are actually hexadecimal numbers that use \"digits\" z-k instead of 0-9a-f.</p> <p>For the git backend, Change IDs are currently maintained only locally and not exchanged via push/fetch operations.</p>"},{"location":"glossary.html#commit","title":"Commit","text":"<p>A snapshot of the files in the repository at a given point in time (technically a tree object), together with some metadata. The metadata includes the author, the date, and pointers to the commit's parents. Through the pointers to the parents, the commits form a Directed Acyclic Graph (DAG) .</p> <p>Note that even though commits are stored as snapshots, they are often treated as differences between snapshots, namely compared to their parent's snapshot. If they have more than one parent, then the difference is computed against the result of merging the parents. For example, <code>jj diff</code> will show the differences introduced by a commit compared to its parent(s), and <code>jj rebase</code> will apply those changes onto another base commit.</p> <p>The word \"revision\" is used as a synonym for \"commit\".</p>"},{"location":"glossary.html#commit-id","title":"Commit ID","text":"<p>A commit ID is a unique identifier for a commit. They are 20 bytes long when using the Git backend. They are presented in regular hexadecimal format at the end of the line in <code>jj log</code>, using 12 hexadecimal digits by default. When using the Git backend, the commit ID is the Git commit ID.</p>"},{"location":"glossary.html#co-located-repos","title":"Co-located repos","text":"<p>When using the Git backend and the backing Git repository's <code>.git/</code> directory is a sibling of <code>.jj/</code>, we call the repository \"co-located\". Most tools designed for Git can be easily used on such repositories. <code>jj</code> and <code>git</code> commands can be used interchangeably.</p> <p>See here for details.</p>"},{"location":"glossary.html#conflict","title":"Conflict","text":"<p>Conflicts can occur in many places. The most common type is conflicts in files. Those are the conflicts that users coming from other VCSs are usually familiar with. You can see them in <code>jj status</code> and in <code>jj log</code> (the red \"conflict\" label at the end of the line). See here for details.</p> <p>Conflicts can also occur in branches. For example, if you moved a branch locally, and it was also moved on the remote, then the branch will be in a conflicted state after you pull from the remote. See here for details.</p> <p>Similar to a branch conflict, when a change is rewritten locally and remotely, for example, then the change will be in a conflicted state. We call that a divergent change.</p>"},{"location":"glossary.html#divergent-change","title":"Divergent change","text":"<p>A divergent change is a change that has more than one visible commit.</p>"},{"location":"glossary.html#head","title":"Head","text":"<p>A head is a commit with no descendants. The context in which it has no descendants varies. For example, the <code>heads(X)</code> revset function returns commits that have no descendants within the set <code>X</code> itself. The view records which anonymous heads (heads without a branch pointing to them) are visible at a given operation. Note that this is quite different from Git's HEAD.</p>"},{"location":"glossary.html#operation","title":"Operation","text":"<p>A snapshot of the visible commits and branches at a given point in time (technically a view object), together with some metadata. The metadata includes the username, hostname, timestamps, and pointers to the operation's parents.</p>"},{"location":"glossary.html#operation-log","title":"Operation log","text":"<p>The operation log is the DAG formed by operation objects, much in the same way that commits form a DAG, which is sometimes called the \"commit history\". When operations happen in sequence, they form a single line in the graph. Operations that happen concurrently from jj's perspective result in forks and merges in the DAG.</p>"},{"location":"glossary.html#repository","title":"Repository","text":"<p>Basically everything under <code>.jj/</code>, i.e. the full set of operations and commits.</p>"},{"location":"glossary.html#remote","title":"Remote","text":"<p>TODO</p>"},{"location":"glossary.html#revision","title":"Revision","text":"<p>A synonym for Commit.</p>"},{"location":"glossary.html#revset","title":"Revset","text":"<p>Jujutsu supports a functional language for selecting a set of revisions. Expressions in this language are called \"revsets\". See here for details. We also often use the term \"revset\" for the set of revisions selected by a revset.</p>"},{"location":"glossary.html#rewrite","title":"Rewrite","text":"<p>To \"rewrite\" a commit means to create a new version of that commit with different contents, metadata (including parent pointers), or both. Rewriting a commit results in a new commit, and thus a new commit ID, but the change ID generally remains the same. Some examples of rewriting a commit would be changing its description or rebasing it. Modifying the working copy rewrites the working copy commit.</p>"},{"location":"glossary.html#root-commit","title":"Root commit","text":"<p>The root commit is a virtual commit at the root of every repository. It has a commit ID consisting of all '0's (<code>00000000...</code>) and a change ID consisting of all 'z's (<code>zzzzzzzz...</code>). It can be referred to in revsets by the function <code>root()</code>. Note that our definition of \"root commit\" is different from Git's; Git's \"root commits\" are the first commit(s) in the repository, i.e. the commits <code>jj log -r root()+</code> will show.</p>"},{"location":"glossary.html#tree","title":"Tree","text":"<p>A tree object represents a snapshot of a directory in the repository. Tree objects are defined recursively; each tree object only has the files and directories contained directly in the directory it represents.</p>"},{"location":"glossary.html#visible-commits","title":"Visible commits","text":"<p>Visible commits are the commits you see in <code>jj log -r 'all()'</code>. They are the commits that are reachable from an anonymous head in the view. Ancestors of a visible commit are implicitly visible.</p>"},{"location":"glossary.html#view","title":"View","text":"<p>A view is a snapshot of branches and their targets, anonymous heads, and working-copy commits. The anonymous heads define which commits are visible.</p> <p>A view object is similar to a tree object in that it represents a snapshot without history, and an operation object is similar to a commit object in that it adds metadata and history.</p>"},{"location":"glossary.html#workspace","title":"Workspace","text":"<p>A workspace is a working copy and an associated repository. There can be multiple workspaces for a single repository. Each workspace has a <code>.jj/</code> directory, but the commits and operations will be stored in the initial workspace; the other workspaces will have pointers to the initial workspace. See here for details.</p> <p>This is what Git calls a \"worktree\".</p>"},{"location":"glossary.html#working-copy","title":"Working copy","text":"<p>The working copy contains the files you're currently working on. It is automatically snapshot at the beginning of almost every <code>jj</code> command, thus creating a new working-copy commit if any changes had been made in the working copy. Conversely, the working copy is automatically updated to the state of the working-copy commit at the end of almost every <code>jj</code> command. See here for details.</p> <p>This is what Git calls a \"working tree\".</p>"},{"location":"glossary.html#working-copy-commit","title":"Working-copy commit","text":"<p>A commit that corresponds to the current state of the working copy. There is one working-copy commit per workspace. The current working-copy commits are tracked in the operation log.</p>"},{"location":"install-and-setup.html","title":"Installation and setup","text":""},{"location":"install-and-setup.html#installation","title":"Installation","text":""},{"location":"install-and-setup.html#download-pre-built-binaries-for-a-release","title":"Download pre-built binaries for a release","text":"<p>There are pre-built binaries of the last released version of <code>jj</code> for Windows, Mac, or Linux (the \"musl\" version should work on all distributions).</p> <p>If you'd like to install a prerelease version, you'll need to use one of the options below.</p>"},{"location":"install-and-setup.html#linux","title":"Linux","text":""},{"location":"install-and-setup.html#build-using-cargo","title":"Build using <code>cargo</code>","text":"<p>First make sure that you have the <code>libssl-dev</code>, <code>openssl</code>, and <code>pkg-config</code> packages installed by running something like this:</p> <pre><code>sudo apt-get install libssl-dev openssl pkg-config\n</code></pre> <p>Now run either:</p> <pre><code># To install the *prerelease* version from the main branch\ncargo install --git https://github.com/martinvonz/jj.git --locked --bin jj jj-cli\n</code></pre> <p>or:</p> <pre><code># To install the latest release\ncargo install --locked --bin jj jj-cli\n</code></pre>"},{"location":"install-and-setup.html#nix-os","title":"Nix OS","text":"<p>If you're on Nix OS you can install a released version of <code>jj</code> using the nixpkgs <code>jujutsu</code> package.</p> <p>To install a prerelease version, you can use the flake for this repository. For example, if you want to run <code>jj</code> loaded from the flake, use:</p> <pre><code>nix run 'github:martinvonz/jj'\n</code></pre> <p>You can also add this flake url to your system input flakes. Or you can install the flake to your user profile:</p> <pre><code># Installs the prerelease version from the main branch\nnix profile install 'github:martinvonz/jj'\n</code></pre>"},{"location":"install-and-setup.html#homebrew","title":"Homebrew","text":"<p>If you use linuxbrew, you can run:</p> <pre><code># Installs the latest release\nbrew install jj\n</code></pre>"},{"location":"install-and-setup.html#mac","title":"Mac","text":""},{"location":"install-and-setup.html#homebrew_1","title":"Homebrew","text":"<p>If you use Homebrew, you can run:</p> <pre><code># Installs the latest release\nbrew install jj\n</code></pre>"},{"location":"install-and-setup.html#macports","title":"MacPorts","text":"<p>You can also install <code>jj</code> via the MacPorts <code>jujutsu</code> port:</p> <pre><code># Installs the latest release\nsudo port install jujutsu\n</code></pre>"},{"location":"install-and-setup.html#from-source","title":"From Source","text":"<p>You may need to run some or all of these:</p> <pre><code>xcode-select --install\nbrew install openssl\nbrew install pkg-config\nexport PKG_CONFIG_PATH=\"$(brew --prefix)/opt/openssl@3/lib/pkgconfig\"\n</code></pre> <p>Now run either:</p> <pre><code># To install the *prerelease* version from the main branch\ncargo install --git https://github.com/martinvonz/jj.git --locked --bin jj jj-cli\n</code></pre> <p>or:</p> <pre><code># To install the latest release\ncargo install --locked --bin jj jj-cli\n</code></pre>"},{"location":"install-and-setup.html#windows","title":"Windows","text":"<p>Run either:</p> <pre><code># To install the *prerelease* version from the main branch\ncargo install --git https://github.com/martinvonz/jj.git --locked --bin jj jj-cli --features vendored-openssl\n</code></pre> <p>or:</p> <pre><code># To install the latest release\ncargo install --locked --bin jj jj-cli --features vendored-openssl\n</code></pre>"},{"location":"install-and-setup.html#initial-configuration","title":"Initial configuration","text":"<p>You may want to configure your name and email so commits are made in your name.</p> <pre><code>$ jj config set --user user.name \"Martin von Zweigbergk\"\n$ jj config set --user user.email \"martinvonz@google.com\"\n</code></pre>"},{"location":"install-and-setup.html#command-line-completion","title":"Command-line completion","text":"<p>To set up command-line completion, source the output of <code>jj util completion --bash/--zsh/--fish</code>. Exactly how to source it depends on your shell.</p>"},{"location":"install-and-setup.html#bash","title":"Bash","text":"<pre><code>source &lt;(jj util completion)  # --bash is the default\n</code></pre>"},{"location":"install-and-setup.html#zsh","title":"Zsh","text":"<pre><code>autoload -U compinit\ncompinit\nsource &lt;(jj util completion --zsh)\n</code></pre>"},{"location":"install-and-setup.html#fish","title":"Fish","text":"<pre><code>jj util completion --fish | source\n</code></pre>"},{"location":"install-and-setup.html#xonsh","title":"Xonsh","text":"<pre><code>source-bash $(jj util completion)\n</code></pre>"},{"location":"operation-log.html","title":"Operation log","text":""},{"location":"operation-log.html#introduction","title":"Introduction","text":"<p>Jujutsu records each operation that modifies the repo in the \"operation log\". You can see the log with <code>jj op log</code>. Each operation object contains a snapshot of how the repo looked at the end of the operation. We call this snapshot a \"view\" object. The view contains information about where each branch, tag, and Git ref (in Git-backed repos) pointed, as well as the set of heads in the repo, and the current working-copy commit in each workspace. The operation object also (in addition to the view) contains pointers to the operation(s) immediately before it, as well as metadata about the operation, such as timestamps, username, hostname, description.</p> <p>The operation log allows you to undo an operation (<code>jj [op] undo</code>), which doesn't need to be the most recent one. It also lets you restore the entire repo to the way it looked at an earlier point (<code>jj op restore</code>).</p> <p>When referring to operations, you can use <code>@</code> to represent the current operation as well as the <code>-</code> operator (e.g. <code>@-</code>) to get the parent of an operation.</p>"},{"location":"operation-log.html#concurrent-operations","title":"Concurrent operations","text":"<p>One benefit of the operation log (and the reason for its creation) is that it allows lock-free concurrency -- you can run concurrent <code>jj</code> commands without corrupting the repo, even if you run the commands on different machines that access the repo via a distributed file system (as long as the file system guarantees that a write is only visible once previous writes are visible). When you run a <code>jj</code> command, it will start by loading the repo at the latest operation. It will not see any changes written by concurrent commands. If there are conflicts, you will be informed of them by subsequent <code>jj st</code> and/or <code>jj log</code> commands.</p> <p>As an example, let's say you had started editing the description of a change and then also update the contents of the change (maybe because you had forgotten the editor). When you eventually close your editor, the command will succeed and e.g. <code>jj log</code> will indicate that the change has diverged.</p>"},{"location":"operation-log.html#loading-an-old-version-of-the-repo","title":"Loading an old version of the repo","text":"<p>The top-level <code>--at-operation/--at-op</code> option allows you to load the repo at a specific operation. This can be useful for understanding how your repo got into the current state. It can be even more useful for understanding why someone else's repo got into its current state.</p> <p>When you use <code>--at-op</code>, the automatic snapshotting of the working copy will not take place. When referring to a revision with the <code>@</code> symbol (as many commands do by default), that will resolve to the working-copy commit recorded in the operation's view (which is actually how it always works -- it's just the snapshotting that's skipped with <code>--at-op</code>).</p> <p>As a top-level option, <code>--at-op</code> can be passed to any command. However, you will typically only want to run read-only commands. For example, <code>jj log</code>, <code>jj st</code>, and <code>jj diff</code> all make sense. It's still possible to run e.g. <code>jj --at-op=&lt;some operation ID&gt; describe</code>. That's equivalent to having started <code>jj describe</code> back when the specified operation was the most recent operation and then let it run until now (which can be done for that particular command by not closing the editor). There's practically no good reason to do that other than to simulate concurrent commands.</p>"},{"location":"related-work.html","title":"Related work","text":"<p>Similar tools:</p> <ul> <li>git-branchless: Helps you use a   branchless workflow in your Git repo. Supports anonymous branching, undo,   and faster rebase (<code>git move</code>). Under heavy development and quickly gaining   new features.</li> <li>Sapling: A heavily modified fork of   Mercurial developed and used at Meta. It   is compatible with Git, has undo functionality, and   a graphical interface.   See how it is different from Jujutsu.</li> <li>GitUp: A Mac-only GUI for Git. Like Jujutsu, supports   undo and restoring the repo to an earlier snapshot. Backed by its   GitUpKit library.</li> <li>Gitless: Another attempt at providing a simpler   interface for Git. Like Jujutsu, does not have an \"index\"/\"staging area\"   concept. Also doesn't move the working-copy changes between branches (which   we do simply as a consequence of making the working copy a commit).</li> <li>Pijul: Architecturally quite different from Jujutsu,   but its \"first-class conflicts\" feature seems quite similar to ours.</li> <li>Breezy: Another VCS that's similar in that it   has multiple storage backends, including its own format as well as .git   support.</li> <li>Sturdy: A Git backed GUI that eliminates local and   remote as well as the idea of an \"index\"/\"staging area\".</li> </ul>"},{"location":"revsets.html","title":"Revsets","text":"<p>Jujutsu supports a functional language for selecting a set of revisions. Expressions in this language are called \"revsets\" (the idea comes from Mercurial). The language consists of symbols, operators, and functions.</p> <p>Most <code>jj</code> commands accept a revset (or multiple). Many commands, such as <code>jj diff -r &lt;revset&gt;</code> expect the revset to resolve to a single commit; it is an error to pass a revset that resolves to more than one commit (or zero commits) to such commands.</p> <p>The words \"revisions\" and \"commits\" are used interchangeably in this document.</p> <p>The commits listed by <code>jj log</code> without arguments are called \"visible commits\". Other commits are only included if you explicitly mention them (e.g. by commit ID or a Git ref pointing to them).</p>"},{"location":"revsets.html#symbols","title":"Symbols","text":"<p>The <code>@</code> expression refers to the working copy commit in the current workspace. Use <code>&lt;workspace name&gt;@</code> to refer to the working-copy commit in another workspace. Use <code>&lt;name&gt;@&lt;remote&gt;</code> to refer to a remote-tracking branch.</p> <p>A full commit ID refers to a single commit. A unique prefix of the full commit ID can also be used. It is an error to use a non-unique prefix.</p> <p>A full change ID refers to all visible commits with that change ID (there is typically only one visible commit with a given change ID). A unique prefix of the full change ID can also be used. It is an error to use a non-unique prefix.</p> <p>Use double quotes to prevent a symbol from being interpreted as an expression. For example, <code>\"x-\"</code> is the symbol <code>x-</code>, not the parents of symbol <code>x</code>. Taking shell quoting into account, you may need to use something like <code>jj log -r '\"x-\"'</code>.</p>"},{"location":"revsets.html#priority","title":"Priority","text":"<p>Jujutsu attempts to resolve a symbol in the following order:</p> <ol> <li>Tag name</li> <li>Branch name</li> <li>Git ref</li> <li>Commit ID or change ID</li> </ol>"},{"location":"revsets.html#operators","title":"Operators","text":"<p>The following operators are supported. <code>x</code> and <code>y</code> below can be any revset, not only symbols.</p> <ul> <li><code>x &amp; y</code>: Revisions that are in both <code>x</code> and <code>y</code>.</li> <li><code>x | y</code>: Revisions that are in either <code>x</code> or <code>y</code> (or both).</li> <li><code>x ~ y</code>: Revisions that are in <code>x</code> but not in <code>y</code>.</li> <li><code>~x</code>: Revisions that are not in <code>x</code>.</li> <li><code>x-</code>: Parents of <code>x</code>.</li> <li><code>x+</code>: Children of <code>x</code>.</li> <li><code>::x</code>: Ancestors of <code>x</code>, including the commits in <code>x</code> itself.</li> <li><code>x::</code>: Descendants of <code>x</code>, including the commits in <code>x</code> itself.</li> <li><code>x::y</code>: Descendants of <code>x</code> that are also ancestors of <code>y</code>. Equivalent    to <code>x:: &amp; ::y</code>. This is what <code>git log</code> calls <code>--ancestry-path x..y</code>.</li> <li><code>::</code>: All visible commits in the repo. Equivalent to <code>all()</code>.</li> <li><code>:x</code>, <code>x:</code>, and <code>x:y</code>: Deprecated versions of <code>::x</code>, <code>x::</code>, and <code>x::y</code> We   plan to delete them in jj 0.15+.</li> <li><code>x..y</code>: Ancestors of <code>y</code> that are not also ancestors of <code>x</code>. Equivalent to   <code>::y ~ ::x</code>. This is what <code>git log</code> calls <code>x..y</code> (i.e. the same as we call it).</li> <li><code>..x</code>: Ancestors of <code>x</code>, including the commits in <code>x</code> itself, but excluding   the root commit. Equivalent to <code>::x ~ root()</code>.</li> <li><code>x..</code>: Revisions that are not ancestors of <code>x</code>.</li> <li><code>..</code>: All visible commits in the repo, but excluding the root commit.   Equivalent to <code>~root()</code>.</li> </ul> <p>You can use parentheses to control evaluation order, such as <code>(x &amp; y) | z</code> or <code>x &amp; (y | z)</code>.</p>"},{"location":"revsets.html#functions","title":"Functions","text":"<p>You can also specify revisions by using functions. Some functions take other revsets (expressions) as arguments.</p> <ul> <li><code>parents(x)</code>: Same as <code>x-</code>.</li> <li><code>children(x)</code>: Same as <code>x+</code>.</li> <li><code>ancestors(x[, depth])</code>: <code>ancestors(x)</code> is the same as <code>::x</code>.    <code>ancestors(x, depth)</code> returns the ancestors of <code>x</code> limited to the given    <code>depth</code>.</li> <li><code>descendants(x)</code>: Same as <code>x::</code>.</li> <li><code>connected(x)</code>: Same as <code>x::x</code>. Useful when <code>x</code> includes several commits.</li> <li><code>all()</code>: All visible commits in the repo.</li> <li><code>none()</code>: No commits. This function is rarely useful; it is provided for   completeness.</li> <li><code>branches([pattern])</code>: All local branch targets. If <code>pattern</code> is specified,   branches whose name contains the given string are selected. For example,   <code>branches(push)</code> would match the branches <code>push-123</code> and <code>repushed</code> but not   the branch <code>main</code>. If a branch is in a conflicted state, all its possible   targets are included.</li> <li><code>remote_branches([branch_pattern[, [remote=]remote_pattern]])</code>: All remote   branch targets across all remotes. If just the <code>branch_pattern</code> is specified,   branches whose name contains the given string across all remotes are   selected. If both <code>branch_pattern</code> and <code>remote_pattern</code> are specified, the   selection is further restricted to just the remotes whose name contains   <code>remote_pattern</code>. For example, <code>remote_branches(push, ri)</code> would match the   branches <code>push-123@origin</code> and <code>repushed@private</code> but not <code>push-123@upstream</code>   or <code>main@origin</code> or <code>main@upstream</code>. If a branch is in a conflicted state,   all its possible targets are included.</li> <li><code>tags()</code>: All tag targets. If a tag is in a conflicted state, all its   possible targets are included.</li> <li><code>git_refs()</code>:  All Git ref targets as of the last import. If a Git ref   is in a conflicted state, all its possible targets are included.</li> <li><code>git_head()</code>: The Git <code>HEAD</code> target as of the last import. Equivalent to   <code>present(HEAD@git)</code>.</li> <li><code>visible_heads()</code>: All visible heads (same as <code>heads(all())</code>).</li> <li><code>root()</code>: The virtual commit that is the oldest ancestor of all other commits.</li> <li><code>heads(x)</code>: Commits in <code>x</code> that are not ancestors of other commits in <code>x</code>.   Note that this is different from   Mercurial's <code>heads(x)</code>   function, which is equivalent to <code>x ~ x-</code>.</li> <li><code>roots(x)</code>: Commits in <code>x</code> that are not descendants of other commits in <code>x</code>.   Note that this is different from   Mercurial's <code>roots(x)</code>   function, which is equivalent to <code>x ~ x+</code>.</li> <li><code>latest(x[, count])</code>: Latest <code>count</code> commits in <code>x</code>, based on committer   timestamp. The default <code>count</code> is 1.</li> <li><code>merges()</code>: Merge commits.</li> <li><code>description(pattern)</code>: Commits with the given string in their   description.</li> <li><code>author(pattern)</code>: Commits with the given string in the author's name or   email.</li> <li><code>mine()</code>: Commits where the author's email matches the email of the current   user.</li> <li><code>committer(pattern)</code>: Commits with the given string in the committer's   name or email.</li> <li><code>empty()</code>: Commits modifying no files. This also includes <code>merges()</code> without   user modifications and <code>root()</code>.</li> <li><code>file(pattern..)</code>: Commits modifying the paths specified by the <code>pattern..</code>.   Paths are relative to the directory <code>jj</code> was invoked from. A directory name   will match all files in that directory and its subdirectories. For example,   <code>file(foo)</code> will match files <code>foo</code>, <code>foo/bar</code>, <code>foo/bar/baz</code>, but not file   <code>foobar</code>.</li> <li><code>conflict()</code>: Commits with conflicts.</li> <li><code>present(x)</code>: Same as <code>x</code>, but evaluated to <code>none()</code> if any of the commits   in <code>x</code> doesn't exist (e.g. is an unknown branch name.)</li> </ul>"},{"location":"revsets.html#string-patterns","title":"String patterns","text":"<p>Functions that perform string matching support the following pattern syntax.</p> <ul> <li><code>\"string\"</code>, <code>substring:\"string\"</code>: Matches strings that contain <code>string</code>.</li> <li><code>exact:\"string\"</code>: Matches strings exactly equal to <code>string</code>.</li> </ul>"},{"location":"revsets.html#aliases","title":"Aliases","text":"<p>New symbols and functions can be defined in the config file, by using any combination of the predefined symbols/functions and other aliases.</p> <p>For example:</p> <pre><code>[revset-aliases]\n'mine' = 'author(martinvonz)'\n'user(x)' = 'author(x) | committer(x)'\n</code></pre>"},{"location":"revsets.html#examples","title":"Examples","text":"<p>Show the parent(s) of the working-copy commit (like <code>git log -1 HEAD</code>):</p> <pre><code>jj log -r @-\n</code></pre> <p>Show commits not on any remote branch:</p> <pre><code>jj log -r 'remote_branches()..'\n</code></pre> <p>Show commits not on <code>origin</code> (if you have other remotes like <code>fork</code>):</p> <pre><code>jj log -r 'remote_branches(remote=origin)..'\n</code></pre> <p>Show all ancestors of the working copy (almost like plain <code>git log</code>)</p> <pre><code>jj log -r ::@\n</code></pre> <p>Show the initial commits in the repo (the ones Git calls \"root commits\"):</p> <pre><code>jj log -r root()+\n</code></pre> <p>Show some important commits (like <code>git --simplify-by-decoration</code>):</p> <pre><code>jj log -r 'tags() | branches()'\n</code></pre> <p>Show local commits leading up to the working copy, as well as descendants of those commits:</p> <pre><code>jj log -r '(remote_branches()..@)::'\n</code></pre> <p>Show commits authored by \"martinvonz\" and containing the word \"reset\" in the description:</p> <pre><code>jj log -r 'author(martinvonz) &amp; description(reset)'\n</code></pre>"},{"location":"sapling-comparison.html","title":"Comparison with Sapling","text":""},{"location":"sapling-comparison.html#introduction","title":"Introduction","text":"<p>This document attempts to describe how jj is different from Sapling. Sapling is a VCS developed by Meta. It is a heavily modified fork of Mercurial. Because jj has copied many ideas from Mercurial, there are many similarities between the two tools, such as:</p> <ul> <li>A user-friendly CLI</li> <li>A \"revset\" language for selecting revisions</li> <li>Good support for working with stacked commits, including tracking \"anonymous   heads\" (no \"detached HEAD\" state like in Git) and <code>split</code> commands, and   automatically rebasing descendant commits when you amend a commit.</li> <li>Flexible customization of output using templates</li> </ul>"},{"location":"sapling-comparison.html#differences","title":"Differences","text":"<p>Here is a list of some differences between jj and Sapling.</p> <ul> <li>Working copy: When using Sapling (like most VCSs), the   user explicitly tells the tool when to create a commit and which files to   include. When using jj, the working copy   is automatically snapshotted by every command. New files   are automatically tracked and deleted files are automatically untracked. This   has several advantages:<ul> <li>The working copy is effectively backed up every time you run a command.</li> <li>No commands fail because you have changes in the working copy (\"abort: 1   conflicting file changes: ...\"). No need for <code>sl shelve</code>.</li> <li>Simpler and more consistent CLI because the working copy is treated like   any other commit.</li> </ul> </li> <li>Conflicts: Like most VCSs, Sapling requires the user to   resolve conflicts before committing. jj lets   you commit conflicts. Note that it's a representation of the   conflict that's committed, not conflict markers (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> etc.). This also   has several advantages:<ul> <li>Merge conflicts won't prevent you from checking out another commit.</li> <li>You can resolve the conflicts when you feel like it.</li> <li>Rebasing descendants always succeeds. Like jj, Sapling automatically   rebases, but it will fail if there are conflicts.</li> <li>Merge commits can be rebased correctly (Sapling sometimes fails).</li> <li>You can rebase conflicts and conflict resolutions.</li> </ul> </li> <li>Undo: jj's undo is powered by the operation log, which   records how the repo has changed over time. Sapling has a similar feature   with its MetaLog.   They seem to provide similar functionality, but jj also exposes the log to the   user via <code>jj op log</code>, so you can tell how far back you want to go back.   Sapling has <code>sl debugmetalog</code>, but that seems to show the history of a single   commit, not the whole repo's history. Thanks to jj snapshotting the working   copy, it's possible to undo changes to the working copy. For example, if   you <code>jj undo</code> a <code>jj commit</code>, <code>jj diff</code> will show the same changes as   before <code>jj commit</code>, but if you <code>sl undo</code> a <code>sl commit</code>, the working copy will   be clean.</li> <li>Git interop: Sapling supports cloning, pushing, and pulling from a remote   Git repo. jj also does, and it also supports sharing a working copy with a Git   repo, so you can use <code>jj</code> and <code>git</code> interchangeably in the same repo.</li> <li>Polish: Sapling is much more polished and feature-complete. For example,   jj has no <code>blame/annotate</code> or <code>bisect</code> commands, and also no copy/rename   support. Sapling also has very nice web UI   called Interactive Smartlog, which   lets you drag and drop commits to rebase them, among other things.</li> <li>Forge workflow: Sapling has <code>sl pr submit --stack</code>, which lets you   push a stack of commits as separate GitHub PRs, including setting the base   branch. It only supports GitHub. jj doesn't have any direct integration with   GitHub or any other forge. However, it has <code>jj git push --change</code> for   automatically creating branches for specified commits. You have to specify   each commit you want to create a branch for by using   <code>jj git push --change X --change Y ...</code>, and you have to manually set up any   base branches in GitHub's UI (or GitLab's or ...). On subsequent pushes, you   can update all at once by specifying something like <code>jj git push -r main..@</code>   (to push all branches on the current stack of commits from where it forked   from <code>main</code>).</li> </ul>"},{"location":"templates.html","title":"Templates","text":"<p>Jujutsu supports a functional language to customize output of commands. The language consists of literals, keywords, operators, functions, and methods.</p> <p>A couple of <code>jj</code> commands accept a template via <code>-T</code>/<code>--template</code> option.</p>"},{"location":"templates.html#keywords","title":"Keywords","text":"<p>Keywords represent objects of different types; the types are described in a follow-up section.</p>"},{"location":"templates.html#commit-keywords","title":"Commit keywords","text":"<p>The following keywords can be used in <code>jj log</code>/<code>jj obslog</code> templates.</p> <ul> <li><code>description: String</code></li> <li><code>change_id: ChangeId</code></li> <li><code>commit_id: CommitId</code></li> <li><code>parents: List&lt;Commit&gt;</code></li> <li><code>author: Signature</code></li> <li><code>committer: Signature</code></li> <li><code>working_copies: String</code>: For multi-workspace repository, indicate   working-copy commit as <code>&lt;workspace name&gt;@</code>.</li> <li><code>current_working_copy: Boolean</code>: True for the working-copy commit of the   current workspace.</li> <li><code>branches: String</code></li> <li><code>tags: String</code></li> <li><code>git_refs: String</code></li> <li><code>git_head: String</code></li> <li><code>divergent: Boolean</code>: True if the commit's change id corresponds to multiple   visible commits.</li> <li><code>hidden: Boolean</code>: True if the commit is not visible (a.k.a. abandoned).</li> <li><code>conflict: Boolean</code>: True if the commit contains merge conflicts.</li> <li><code>empty: Boolean</code>: True if the commit modifies no files.</li> <li><code>root: Boolean</code>: True if the commit is the root commit.</li> </ul>"},{"location":"templates.html#operation-keywords","title":"Operation keywords","text":"<p>The following keywords can be used in <code>jj op log</code> templates.</p> <ul> <li><code>current_operation: Boolean</code></li> <li><code>description: String</code></li> <li><code>id: OperationId</code></li> <li><code>tags: String</code></li> <li><code>time: TimestampRange</code></li> <li><code>user: String</code></li> </ul>"},{"location":"templates.html#operators","title":"Operators","text":"<p>The following operators are supported.</p> <ul> <li><code>x.f()</code>: Method call.</li> <li><code>x ++ y</code>: Concatenate <code>x</code> and <code>y</code> templates.</li> </ul>"},{"location":"templates.html#global-functions","title":"Global functions","text":"<p>The following functions are defined.</p> <ul> <li><code>fill(width: Integer, content: Template) -&gt; Template</code>: Fill lines at   the given <code>width</code>.</li> <li><code>indent(prefix: Template, content: Template) -&gt; Template</code>: Indent   non-empty lines by the given <code>prefix</code>.</li> <li><code>label(label: Template, content: Template) -&gt; Template</code>: Apply label to   the content. The <code>label</code> is evaluated as a space-separated string.</li> <li><code>if(condition: Boolean, then: Template[, else: Template]) -&gt; Template</code>:   Conditionally evaluate <code>then</code>/<code>else</code> template content.</li> <li><code>concat(content: Template...) -&gt; Template</code>:   Same as <code>content_1 ++ ... ++ content_n</code>.</li> <li><code>separate(separator: Template, content: Template...) -&gt; Template</code>:   Insert separator between non-empty contents.</li> </ul>"},{"location":"templates.html#types","title":"Types","text":""},{"location":"templates.html#boolean-type","title":"Boolean type","text":"<p>No methods are defined. Can be constructed with <code>false</code> or <code>true</code> literal.</p>"},{"location":"templates.html#commit-type","title":"Commit type","text":"<p>This type cannot be printed. All commit keywords are accessible as 0-argument methods.</p>"},{"location":"templates.html#commitid-changeid-type","title":"CommitId / ChangeId type","text":"<p>The following methods are defined.</p> <ul> <li><code>.short([len: Integer]) -&gt; String</code></li> <li><code>.shortest([min_len: Integer]) -&gt; ShortestIdPrefix</code>: Shortest unique prefix.</li> </ul>"},{"location":"templates.html#integer-type","title":"Integer type","text":"<p>No methods are defined.</p>"},{"location":"templates.html#list-type","title":"List type","text":"<p>The following methods are defined.</p> <ul> <li><code>.join(separator: Template) -&gt; Template</code>: Concatenate elements with   the given <code>separator</code>.</li> <li><code>.map(|item| expression) -&gt; ListTemplate</code>: Apply template <code>expression</code>   to each element. Example: <code>parents.map(|c| c.commit_id().short())</code></li> </ul>"},{"location":"templates.html#listtemplate-type","title":"ListTemplate type","text":"<p>The following methods are defined. See also the <code>List</code> type.</p> <ul> <li><code>.join(separator: Template) -&gt; Template</code></li> </ul>"},{"location":"templates.html#operationid-type","title":"OperationId type","text":"<p>The following methods are defined.</p> <ul> <li><code>.short([len: Integer]) -&gt; String</code></li> </ul>"},{"location":"templates.html#shortestidprefix-type","title":"ShortestIdPrefix type","text":"<p>The following methods are defined.</p> <ul> <li><code>.prefix() -&gt; String</code></li> <li><code>.rest() -&gt; String</code></li> <li><code>.upper() -&gt; ShortestIdPrefix</code></li> <li><code>.lower() -&gt; ShortestIdPrefix</code></li> </ul>"},{"location":"templates.html#signature-type","title":"Signature type","text":"<p>The following methods are defined.</p> <ul> <li><code>.name() -&gt; String</code></li> <li><code>.email() -&gt; String</code></li> <li><code>.username() -&gt; String</code></li> <li><code>.timestamp() -&gt; Timestamp</code></li> </ul>"},{"location":"templates.html#string-type","title":"String type","text":"<p>A string can be implicitly converted to <code>Boolean</code>. The following methods are defined.</p> <ul> <li><code>.contains(needle: Template) -&gt; Boolean</code></li> <li><code>.first_line() -&gt; String</code></li> <li><code>.lines() -&gt; List&lt;String&gt;</code>: Split into lines excluding newline characters.</li> <li><code>.upper() -&gt; String</code></li> <li><code>.lower() -&gt; String</code></li> <li><code>.starts_with(needle: Template) -&gt; Boolean</code></li> <li><code>.ends_with(needle: Template) -&gt; Boolean</code></li> <li><code>.remove_prefix(needle: Template) -&gt; String</code>: Removes the passed prefix, if present</li> <li><code>.remove_suffix(needle: Template) -&gt; String</code>: Removes the passed suffix, if present</li> <li><code>.substr(start: Integer, end: Integer) -&gt; String</code>: Extract substring. Negative values count from the end.</li> </ul>"},{"location":"templates.html#template-type","title":"Template type","text":"<p>Most types can be implicitly converted to <code>Template</code>. No methods are defined.</p>"},{"location":"templates.html#timestamp-type","title":"Timestamp type","text":"<p>The following methods are defined.</p> <ul> <li><code>.ago() -&gt; String</code>: Format as relative timestamp.</li> <li><code>.format(format: String) -&gt; String</code>: Format with the specified strftime-like   format string.</li> <li><code>.utc() -&gt; Timestamp</code>: Convert timestamp into UTC timezone.</li> </ul>"},{"location":"templates.html#timestamprange-type","title":"TimestampRange type","text":"<p>The following methods are defined.</p> <ul> <li><code>.start() -&gt; Timestamp</code></li> <li><code>.end() -&gt; Timestamp</code></li> <li><code>.duration() -&gt; String</code></li> </ul>"},{"location":"templates.html#configuration","title":"Configuration","text":"<p>The default templates and aliases() are defined in the <code>[templates]</code> and <code>[template-aliases]</code> sections of the config respectively. The exact definitions can be seen in the <code>cli/src/config/templates.toml</code> file in jj's source tree.</p> <p>New keywords and functions can be defined as aliases, by using any combination of the predefined keywords/functions and other aliases.</p> <p>For example:</p> <pre><code>[template-aliases]\n'commit_change_ids' = '''\nconcat(\n  format_field(\"Commit ID\", commit_id),\n  format_field(\"Change ID\", commit_id),\n)\n'''\n'format_field(key, value)' = 'key ++ \": \" ++ value ++ \"\\n\"'\n</code></pre>"},{"location":"tutorial.html","title":"Tutorial","text":"<p>This text assumes that the reader is familiar with Git.</p>"},{"location":"tutorial.html#preparation","title":"Preparation","text":"<p>If you haven't already, make sure you install and configure Jujutsu.</p>"},{"location":"tutorial.html#cloning-a-git-repo","title":"Cloning a Git repo","text":"<p>Let's start by cloning GitHub's Hello-World repo using <code>jj</code>: <pre><code># Note the \"git\" before \"clone\" (there is no support for cloning native jj\n# repos yet)\n$ jj git clone https://github.com/octocat/Hello-World\nFetching into new repo in \"/tmp/tmp.O1DWMiaKd4/Hello-World\"\nWorking copy now at: d7439b06fbef (no description set)\nAdded 1 files, modified 0 files, removed 0 files\n$ cd Hello-World\n</code></pre></p> <p>Running <code>jj st</code> (short for<code>jj status</code>) now yields something like this: <pre><code>$ jj st\nParent commit: 7fd1a60b01f9 Merge pull request #6 from Spaceghost/patch-1\nWorking copy : d7439b06fbef (no description set)\nThe working copy is clean\n</code></pre></p> <p>We can see from the output above that our working copy is a real commit with a commit ID (<code>d7439b06fbef</code> in the example). When you make a change in the working copy, the working-copy commit gets automatically amended by the next <code>jj</code> command.</p>"},{"location":"tutorial.html#creating-our-first-change","title":"Creating our first change","text":"<p>Now let's say we want to edit the <code>README</code> file in the repo to say \"Goodbye\" instead of \"Hello\". Let's start by describing the change (adding a commit message) so we don't forget what we're working on: <pre><code># This will bring up $EDITOR (or `pico` or `Notepad` by default). Enter\n# something like \"Say goodbye\" in the editor and then save the file and close\n# the editor.\n$ jj describe\nWorking copy now at: e427edcfd0ba Say goodbye\n</code></pre></p> <p>Now make the change in the README: <pre><code># Adjust as necessary for compatibility with your flavor of `sed`\n$ sed -i 's/Hello/Goodbye/' README\n$ jj st\nParent commit: 7fd1a60b01f9 Merge pull request #6 from Spaceghost/patch-1\nWorking copy : 5d39e19dac36 Say goodbye\nWorking copy changes:\nM README\n</code></pre> Note that you didn't have to tell Jujutsu to add the change like you would with <code>git add</code>. You actually don't even need to tell it when you add new files or remove existing files. To untrack a path, add it to your <code>.gitignore</code> and run <code>jj untrack &lt;path&gt;</code>.</p> <p>To see the diff, run <code>jj diff</code>: <pre><code>$ jj diff --git  # Feel free to skip the `--git` flag\ndiff --git a/README b/README\nindex 980a0d5f19...1ce3f81130 100644\n--- a/README\n+++ b/README\n@@ -1,1 +1,1 @@\n-Hello World!\n+Goodbye World!\n</code></pre> Jujutsu's diff format currently defaults to inline coloring of the diff (like <code>git diff --color-words</code>), so we used <code>--git</code> above to make the diff readable in this tutorial.</p> <p>As you may have noticed, the working-copy commit's ID changed both when we edited the description and when we edited the README. However, the parent commit stayed the same. Each change to the working-copy commit amends the previous version. So how do we tell Jujutsu that we are done amending the current change and want to start working on a new one? That is what <code>jj new</code> is for. That will create a new commit on top of your current working-copy commit. The new commit is for the working-copy changes. For familiarity for user coming from other VCSs, there is also a <code>jj checkout/co</code> command, which is practically a synonym for <code>jj new</code> (you can specify a destination for <code>jj new</code> as well).</p> <p>So, let's say we're now done with this change, so we create a new change: <pre><code>$ jj new\nWorking copy now at: aef4df99ea11 (no description set)\n$ jj st\nParent commit: 5d39e19dac36 Say goodbye\nWorking copy : aef4df99ea11 (no description set)\nThe working copy is clean\n</code></pre></p> <p>If we later realize that we want to make further changes, we can make them in the working copy and then run <code>jj squash</code>. That command squashes the changes from a given commit into its parent commit. Like most commands, it acts on the working-copy commit by default. When run on the working-copy commit, it behaves very similar to <code>git commit --amend</code>, and <code>jj amend</code> is in fact an alias for <code>jj squash</code>.</p> <p>Alternatively, we can use <code>jj edit &lt;commit&gt;</code> to resume editing a commit in the working copy. Any further changes in the working copy will then amend the commit. Whether you choose to checkout-and-squash or to edit typically depends on how done you are with the change; if the change is almost done, it makes sense to use <code>jj checkout</code> so you can easily review your adjustments with <code>jj diff</code> before running <code>jj squash</code>. </p>"},{"location":"tutorial.html#the-log-command-and-revsets","title":"The log command and \"revsets\"","text":"<p>You're probably familiar with <code>git log</code>. Jujutsu has very similar functionality in its <code>jj log</code> command: <pre><code>$ jj log\n@  mpqrykypylvy martinvonz@google.com 2023-02-12 15:00:22.000 -08:00 aef4df99ea11\n\u2502  (empty) (no description set)\n\u25c9  kntqzsqtnspv martinvonz@google.com 2023-02-12 14:56:59.000 -08:00 5d39e19dac36\n\u2502  Say goodbye\n\u25c9  orrkosyozysx octocat@nowhere.com 2012-03-06 15:06:50.000 -08:00 master 7fd1a60b01f9\n\u2502  (empty) Merge pull request #6 from Spaceghost/patch-1\n~\n</code></pre></p> <p>The <code>@</code> indicates the working-copy commit. The first ID on a line (e.g. \"mpqrykypylvy\" above) is the \"change ID\", which is an ID that follows the commit as it's rewritten (similar to Gerrit's Change-Id). The second ID is the commit ID, which changes when you rewrite the commit. You can give either ID to commands that take revisions as arguments. We will generally prefer change IDs because they stay the same when the commit is rewritten.</p> <p>By default, <code>jj log</code> lists your local commits, with some remote commits added for context.  The <code>~</code> indicates that the commit has parents that are not included in the graph. We can use the <code>-r</code> flag to select a different set of revisions to list. The flag accepts a \"revset\", which is an expression in a simple language for specifying revisions. For example, <code>@</code> refers to the working-copy commit, <code>root()</code> refers to the root commit, <code>branches()</code> refers to all commits pointed to by branches. We can combine expressions with <code>|</code> for union, <code>&amp;</code> for intersection and <code>~</code> for difference. For example: <pre><code>$ jj log -r '@ | root() | branches()'\n@  mpqrykypylvy martinvonz@google.com 2023-02-12 15:00:22.000 -08:00 aef4df99ea11\n\u2577  (empty) (no description set)\n\u2577 \u25c9  kowxouwzwxmv octocat@nowhere.com 2014-06-10 15:22:26.000 -07:00 test b3cbd5bbd7e8\n\u256d\u2500\u256f  Create CONTRIBUTING.md\n\u2502 \u25c9  tpstlustrvsn support+octocat@github.com 2018-05-10 12:55:19.000 -05:00 octocat-patch-1 b1b3f9723831\n\u251c\u2500\u256f  sentence case\n\u25c9  orrkosyozysx octocat@nowhere.com 2012-03-06 15:06:50.000 -08:00 master 7fd1a60b01f9\n\u2577  (empty) Merge pull request #6 from Spaceghost/patch-1\n\u25c9  zzzzzzzzzzzz 1970-01-01 00:00:00.000 +00:00 000000000000\n(empty) (no description set)\n</code></pre></p> <p>The <code>000000000000</code> commit (change ID <code>zzzzzzzzzzzz</code>) is a virtual commit that's called the \"root commit\". It's the root commit of every repo. The <code>root()</code> function in the revset matches it.</p> <p>There are also operators for getting the parents (<code>foo-</code>), children (<code>foo+</code>), ancestors (<code>::foo</code>), descendants (<code>foo::</code>), DAG range (<code>foo::bar</code>, like <code>git log --ancestry-path</code>), range (<code>foo..bar</code>, same as Git's). There are also a few more functions, such as <code>heads(&lt;set&gt;)</code>, which filters out revisions in the input set if they're ancestors of other revisions in the set.</p>"},{"location":"tutorial.html#conflicts","title":"Conflicts","text":"<p>Now let's see how Jujutsu deals with merge conflicts. We'll start by making some commits: <pre><code># Start creating a chain of commits off of the `master` branch\n$ jj new master -m A; echo a &gt; file1\nWorking copy now at: 00a2aeed556a A\nAdded 0 files, modified 1 files, removed 0 files\n$ jj new -m B1; echo b1 &gt; file1\nWorking copy now at: 967d9f9fd288 B1\n$ jj new -m B2; echo b2 &gt; file1\nWorking copy now at: 8ebeaffa332b B2\n$ jj new -m C; echo c &gt; file2\nWorking copy now at: 62a3c6d315cd C\n$ jj log\n@  qzvqqupxlkot martinvonz@google.com 2023-02-12 15:07:41.946 -08:00 2370ddf3fa39\n\u2502  C\n\u25c9  puqltuttrvzp martinvonz@google.com 2023-02-12 15:07:33.000 -08:00 daa6ffd5a09a\n\u2502  B2\n\u25c9  ovknlmrokpkl martinvonz@google.com 2023-02-12 15:07:24.000 -08:00 7d7c6e6bd0b4\n\u2502  B1\n\u25c9  nuvyytnqlquo martinvonz@google.com 2023-02-12 15:07:05.000 -08:00 5dda2f097aa9\n\u2502  A\n\u2502 \u25c9  kntqzsqtnspv martinvonz@google.com 2023-02-12 14:56:59.000 -08:00 5d39e19dac36\n\u251c\u2500\u256f  Say goodbye\n\u25c9  orrkosyozysx octocat@nowhere.com 2012-03-06 15:06:50.000 -08:00 master 7fd1a60b01f9\n\u2502  (empty) Merge pull request #6 from Spaceghost/patch-1\n~\n</code></pre></p> <p>We now have a few commits, where A, B1, and B2 modify the same file, while C modifies a different file. Let's now rebase B2 directly onto A: <pre><code>$ jj rebase -s puqltuttrvzp -d nuvyytnqlquo\nRebased 2 commits\nWorking copy now at: 1978b53430cd C\nAdded 0 files, modified 1 files, removed 0 files\n$ jj log\n@  qzvqqupxlkot martinvonz@google.com 2023-02-12 15:08:33.000 -08:00 1978b53430cd conflict\n\u2502  C\n\u25c9  puqltuttrvzp martinvonz@google.com 2023-02-12 15:08:33.000 -08:00 f7fb5943ee41 conflict\n\u2502  B2\n\u2502 \u25c9  ovknlmrokpkl martinvonz@google.com 2023-02-12 15:07:24.000 -08:00 7d7c6e6bd0b4\n\u251c\u2500\u256f  B1\n\u25c9  nuvyytnqlquo martinvonz@google.com 2023-02-12 15:07:05.000 -08:00 5dda2f097aa9\n\u2502  A\n\u2502 \u25c9  kntqzsqtnspv martinvonz@google.com 2023-02-12 14:56:59.000 -08:00 5d39e19dac36\n\u251c\u2500\u256f  Say goodbye\n\u25c9  orrkosyozysx octocat@nowhere.com 2012-03-06 15:06:50.000 -08:00 master 7fd1a60b01f9\n\u2502  (empty) Merge pull request #6 from Spaceghost/patch-1\n~\n</code></pre></p> <p>There are several things worth noting here. First, the <code>jj rebase</code> command said \"Rebased 2 commits\". That's because we asked it to rebase commit B2 with the <code>-s</code> option, which also rebases descendants (commit C in this case). Second, because B2 modified the same file (and word) as B1, rebasing it resulted in conflicts, as the <code>jj log</code> output indicates. Third, the conflicts did not prevent the rebase from completing successfully, nor did it prevent C from getting rebased on top.</p> <p>Now let's resolve the conflict in B2. We'll do that by creating a new commit on top of B2. Once we've resolved the conflict, we'll squash the conflict resolution into the conflicted B2. That might look like this: <pre><code>$ jj new puqltuttrvzp  # Replace the ID by what you have for B2\nWorking copy now at: c7068d1c23fd (no description set)\nAdded 0 files, modified 0 files, removed 1 files\n$ jj st\nParent commit: f7fb5943ee41 B2\nWorking copy : c7068d1c23fd (no description set)\nThe working copy is clean\nThere are unresolved conflicts at these paths:\nfile1    2-sided conflict\n$ cat file1\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n%%%%%%%\n-b1\n+a\n+++++++\nb2\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n$ echo resolved &gt; file1\n$ jj squash\nRebased 1 descendant commits\nWorking copy now at: e3c279cc2043 (no description set)\n$ jj log\n@  ntxxqymrlvxu martinvonz@google.com 2023-02-12 19:34:09.000 -08:00 e3c279cc2043\n\u2502  (empty) (no description set)\n\u2502 \u25c9  qzvqqupxlkot martinvonz@google.com 2023-02-12 19:34:09.000 -08:00 b9da9d28b26b\n\u251c\u2500\u256f  C\n\u25c9  puqltuttrvzp martinvonz@google.com 2023-02-12 19:34:09.000 -08:00 2c7a658e2586\n\u2502  B2\n\u2502 \u25c9  ovknlmrokpkl martinvonz@google.com 2023-02-12 15:07:24.000 -08:00 7d7c6e6bd0b4\n\u251c\u2500\u256f  B1\n\u25c9  nuvyytnqlquo martinvonz@google.com 2023-02-12 15:07:05.000 -08:00 5dda2f097aa9\n\u2502  A\n\u2502 \u25c9  kntqzsqtnspv martinvonz@google.com 2023-02-12 14:56:59.000 -08:00 5d39e19dac36\n\u251c\u2500\u256f  Say goodbye\n\u25c9  orrkosyozysx octocat@nowhere.com 2012-03-06 15:06:50.000 -08:00 master 7fd1a60b01f9\n\u2502  (empty) Merge pull request #6 from Spaceghost/patch-1\n~\n</code></pre></p> <p>Note that commit C automatically got rebased on top of the resolved B2, and that C is also resolved (since it modified only a different file).</p> <p>By the way, if we want to get rid of B1 now, we can run <code>jj abandon ovknlmrokpkl</code>. That will hide the commit from the log output and will rebase any descendants to its parent.</p>"},{"location":"tutorial.html#the-operation-log","title":"The operation log","text":"<p>Jujutsu keeps a record of all changes you've made to the repo in what's called the \"operation log\". Use the <code>jj op</code> (short for <code>jj operation</code>) family of commands to interact with it. To list the operations, use <code>jj op log</code>: <pre><code>$ jj op log\n@  d3b77addea49 martinvonz@vonz.svl.corp.google.com 2023-02-12 19:34:09.549 -08:00 - 2023-02-12 19:34:09.552 -08:00\n\u2502  squash commit 63874fe6c4fba405ffc38b0dd926f03b715cf7ef\n\u2502  args: jj squash\n\u25c9  6fc1873c1180 martinvonz@vonz.svl.corp.google.com 2023-02-12 19:34:09.548 -08:00 - 2023-02-12 19:34:09.549 -08:00\n\u2502  snapshot working copy\n\u25c9  ed91f7bcc1fb martinvonz@vonz.svl.corp.google.com 2023-02-12 19:32:46.007 -08:00 - 2023-02-12 19:32:46.008 -08:00\n\u2502  new empty commit\n\u2502  args: jj new puqltuttrvzp\n\u25c9  367400773f87 martinvonz@vonz.svl.corp.google.com 2023-02-12 15:08:33.917 -08:00 - 2023-02-12 15:08:33.920 -08:00\n\u2502  rebase commit daa6ffd5a09a8a7d09a65796194e69b7ed0a566d and descendants\n\u2502  args: jj rebase -s puqltuttrvzp -d nuvyytnqlquo\n[many more lines]\n</code></pre></p> <p>The most useful command is <code>jj undo</code> (alias for <code>jj op undo</code>), which will undo an operation. By default, it will undo the most recent operation. Let's try it: <pre><code>$ jj undo\nWorking copy now at: 63874fe6c4fb (no description set)\n$ jj log\n@  zxoosnnpvvpn martinvonz@google.com 2023-02-12 19:34:09.000 -08:00 63874fe6c4fb\n\u2502  (no description set)\n\u2502 \u25c9  qzvqqupxlkot martinvonz@google.com 2023-02-12 15:08:33.000 -08:00 1978b53430cd conflict\n\u251c\u2500\u256f  C\n\u25c9  puqltuttrvzp martinvonz@google.com 2023-02-12 15:08:33.000 -08:00 f7fb5943ee41 conflict\n\u2502  B2\n\u2502 \u25c9  ovknlmrokpkl martinvonz@google.com 2023-02-12 15:07:24.000 -08:00 7d7c6e6bd0b4\n\u251c\u2500\u256f  B1\n\u25c9  nuvyytnqlquo martinvonz@google.com 2023-02-12 15:07:05.000 -08:00 5dda2f097aa9\n\u2502  A\n\u2502 \u25c9  kntqzsqtnspv martinvonz@google.com 2023-02-12 14:56:59.000 -08:00 5d39e19dac36\n\u251c\u2500\u256f  Say goodbye\n\u25c9  orrkosyozysx octocat@nowhere.com 2012-03-06 15:06:50.000 -08:00 master 7fd1a60b01f9\n\u2502  (empty) Merge pull request #6 from Spaceghost/patch-1\n~\n</code></pre> As you can perhaps see, that undid the <code>jj squash</code> invocation we used for squashing the conflict resolution into commit B2 earlier. Notice that it also updated the working copy.</p> <p>You can also view the repo the way it looked after some earlier operation. For example, if you want to see <code>jj log</code> output right after the <code>jj rebase</code> operation, try <code>jj log --at-op=367400773f87</code> but use the hash from your own <code>jj op log</code>.</p>"},{"location":"tutorial.html#moving-content-changes-between-commits","title":"Moving content changes between commits","text":"<p>You have already seen how <code>jj squash</code> can combine the changes from two commits into one. There are several other commands for changing the contents of existing commits. These commands assume that you have <code>meld</code> installed. If you prefer a terminal-based diff editor, you can configure <code>scm-diff-editor</code> instead.</p> <p>We'll need some more complex content to test these commands, so let's create a few more commits: <pre><code>$ jj new master -m abc; printf 'a\\nb\\nc\\n' &gt; file\nWorking copy now at: f94e49cf2547 abc\nAdded 0 files, modified 0 files, removed 1 files\n$ jj new -m ABC; printf 'A\\nB\\nc\\n' &gt; file\nWorking copy now at: 6f30cd1fb351 ABC\n$ jj new -m ABCD; printf 'A\\nB\\nC\\nD\\n' &gt; file\nWorking copy now at: a67491542e10 ABCD\n$ jj log -r master::@\n@  mrxqplykzpkw martinvonz@google.com 2023-02-12 19:38:21.000 -08:00 b98c607bf87f\n\u2502  ABCD\n\u25c9  kwtuwqnmqyqp martinvonz@google.com 2023-02-12 19:38:12.000 -08:00 30aecc0871ea\n\u2502  ABC\n\u25c9  ztqrpvnwqqnq martinvonz@google.com 2023-02-12 19:38:03.000 -08:00 510022615871\n\u2502  abc\n\u25c9  orrkosyozysx octocat@nowhere.com 2012-03-06 15:06:50.000 -08:00 master 7fd1a60b01f9\n\u2502  (empty) Merge pull request #6 from Spaceghost/patch-1\n~\n</code></pre></p> <p>We \"forgot\" to capitalize \"c\" in the second commit when we capitalized the other letters. We then fixed that in the third commit when we also added \"D\". It would be cleaner to move the capitalization of \"c\" into the second commit. We can do that by running <code>jj squash -i</code> (short for <code>jj squash --interactive</code>) on the third commit. Remember that <code>jj squash</code> moves all the changes from one commit into its parent. <code>jj squash -i</code> moves only part of the changes into its parent. Now try that: <pre><code>$ jj squash -i\nUsing default editor 'meld'; you can change this by setting ui.diff-editor\nWorking copy now at: 52a6c7fda1e3 ABCD\n</code></pre> That will bring up Meld with a diff of the changes in the \"ABCD\" commit. Modify the right side of the diff to have the desired end state in \"ABC\" by removing the \"D\" line. Then save the changes and close Meld. If we look at the diff of the second commit, we now see that all three lines got capitalized: <pre><code>$ jj diff -r @-\nModified regular file file:\n   1    1: aA\n   2    2: bB\n   3    3: cC\n</code></pre></p> <p>The child change (\"ABCD\" in our case) will have the same content state after the <code>jj squash</code> command. That means that you can move any changes you want into the parent change, even if they touch the same word, and it won't cause any conflicts.</p> <p>Let's try one final command for changing the contents of an exiting commit. That command is <code>jj diffedit</code>, which lets you edit the contents of a commit without checking it out. <pre><code>$ jj diffedit -r @-\nUsing default editor 'meld'; you can change this by setting ui.diff-editor\nCreated 70985eaa924f ABC\nRebased 1 descendant commits\nWorking copy now at: 1c72cd50525d ABCD\nAdded 0 files, modified 1 files, removed 0 files\n</code></pre> When Meld starts, edit the right side by e.g. adding something to the first line. Then save the changes and close Meld. You can now inspect the rewritten commit with <code>jj diff -r @-</code> again and you should see your addition to the first line. Unlike <code>jj squash -i</code>, which left the content state of the commit unchanged, <code>jj diffedit</code> (typically) results in a different state, which means that descendant commits may have conflicts.</p> <p>Other commands for rewriting contents of existing commits are <code>jj split</code>, <code>jj unsquash -i</code> and <code>jj move -i</code>. Now that you've seen how <code>jj squash -i</code> and <code>jj diffedit</code> work, you can hopefully figure out how those work (with the help of the instructions in the diff).</p>"},{"location":"working-copy.html","title":"Working copy","text":""},{"location":"working-copy.html#introduction","title":"Introduction","text":"<p>The working copy is where the current working-copy commit's files are written so you can interact with them. It also where files are read from in order to create new commits (though there are many other ways of creating new commits).</p> <p>Unlike most other VCSs, Jujutsu will automatically create commits from the working-copy contents when they have changed. Most <code>jj</code> commands you run will commit the working-copy changes if they have changed. The resulting revision will replace the previous working-copy revision.</p> <p>Also unlike most other VCSs, added files are implicitly tracked. That means that if you add a new file to the working copy, it will be automatically committed once you run e.g. <code>jj st</code>. Similarly, if you remove a file from the working copy, it will implicitly be untracked. To untrack a file while keeping it in the working copy, first make sure it's ignored and then run <code>jj untrack &lt;path&gt;</code>.</p>"},{"location":"working-copy.html#conflicts","title":"Conflicts","text":"<p>When you check out a commit with conflicts, those conflicts need to be represented in the working copy somehow. However, the file system doesn't understand conflicts. Jujutsu's solution is to add conflict markers to conflicted files when it writes them to the working copy. It also keeps track of the (typically 3) different parts involved in the conflict. Whenever it scans the working copy thereafter, it parses the conflict markers and recreates the conflict state from them. You can resolve conflicts by replacing the conflict markers by the resolved text. You don't need to resolve all conflicts at once. You can even resolve part of a conflict by updating the different parts of the conflict marker.</p> <p>To resolve conflicts in a commit, use <code>jj new &lt;commit&gt;</code> to create a working-copy commit on top. You would then have the same conflicts in the working-copy commit. Once you have resolved the conflicts, you can inspect the conflict resolutions with <code>jj diff</code>. Then run <code>jj squash</code> to move the conflict resolutions into the conflicted commit. Alternatively, you can edit the commit with conflicts directly in the working copy by using <code>jj edit &lt;commit&gt;</code>. The main disadvantage of that is that it's harder to inspect the conflict resolutions.</p> <p>With the <code>jj resolve</code> command, you can use an external merge tool to resolve conflicts that have 2 sides and a base.  There is not yet a good way of resolving conflicts between directories, files, and symlinks (https://github.com/martinvonz/jj/issues/19). You can use <code>jj restore</code> to choose one side of the conflict, but there's no way to even see where the involved parts came from.</p>"},{"location":"working-copy.html#ignored-files","title":"Ignored files","text":"<p>You probably don't want build outputs and temporary files to be under version control. You can tell Jujutsu to not automatically track certain files by using <code>.gitignore</code> files (there's no such thing as <code>.jjignore</code> yet). See https://git-scm.com/docs/gitignore for details about the format. <code>.gitignore</code> files are supported in any directory in the working copy, as well as in <code>$HOME/.gitignore</code>. However, <code>$GIT_DIR/info/exclude</code> or equivalent way (maybe <code>.jj/gitignore</code>) of specifying per-clone ignores is not yet supported.</p>"},{"location":"working-copy.html#workspaces","title":"Workspaces","text":"<p>You can have multiple working copies backed by a single repo. Use  <code>jj workspace add</code> to create a new working copy. The working copy will have a <code>.jj/</code> directory linked to the main repo. The working copy and the <code>.jj/</code> directory together is called a \"workspace\". Each workspace can have a different commit checked out.</p> <p>Having multiple workspaces can be useful for running long-running tests in a one while you continue developing in another, for example. If needed, <code>jj workspace root</code> prints the root path of the current workspace.</p> <p>When you're done using a workspace, use <code>jj workspace forget</code> to make the repo forget about it. The files can be deleted from disk separately (either before or after).</p>"},{"location":"working-copy.html#stale-working-copy","title":"Stale working copy","text":"<p>When you modify workspace A's working-copy commit from workspace B, workspace A's working copy will become stale. By \"stale\", we mean that the files in the working copy don't match the desired commit indicated by the <code>@</code> symbol in <code>jj log</code>. When that happens, use <code>jj workspace update-stale</code> to update the files in the working copy.</p>"},{"location":"design/git-submodule-storage.html","title":"Git submodule storage","text":""},{"location":"design/git-submodule-storage.html#objective","title":"Objective","text":"<p>Decide what approach(es) to Git submodule storage we should pursue. The decision will be recorded in ./git-submodules.md.</p>"},{"location":"design/git-submodule-storage.html#use-cases-to-consider","title":"Use cases to consider","text":"<p>The submodule storage format should support the workflows specified in the submodules roadmap. It should be obvious how \"Phase 1\" requirements will be supported, and we should have an idea of how \"Phases 2,3,X\" might be supported.</p> <p>Notable use cases and workflows are noted below.</p>"},{"location":"design/git-submodule-storage.html#fetching-submodule-commits","title":"Fetching submodule commits","text":"<p>Git's protocol is designed for communicating between copies of the same repository. Notably, a Git fetch calculates the list of required objects by performing reachability checks between the refs on the local and the remote side. We should expect that this will only work well if the submodule repository is stored as a local Git repository.</p> <p>Rolling our own Git fetch is too complex to be worth the effort.</p>"},{"location":"design/git-submodule-storage.html#jj-op-restore-and-operation-log-format","title":"\"jj op restore\" and operation log format","text":"<p>We want <code>jj op restore</code> to restore to an \"expected\" state in the submodule. There is a potential distinction between running <code>jj op restore</code> in the superproject vs in the submodule, and the expected behavior may be different in each case, e.g. in the superproject, it might be enough to restore the submodule working copy, but in the submodule, refs also need to be restored.</p> <p>Currently, the operation log only references objects and refs in the superproject, so it is likely that proposed approaches will need to extend this format. It is also worth considering that submodules may be added, updated or removed in superproject commits, thus the list of submodules is likely to change over the repository's lifetime.</p>"},{"location":"design/git-submodule-storage.html#nested-submodules","title":"Nested submodules","text":"<p>Git submodules may contain submodules themselves, so our chosen storage schemes should support that.</p> <p>We should consider limiting the recursion depth to avoid nasty edge cases (e.g. cyclical submodules.) that might surprise users.</p>"},{"location":"design/git-submodule-storage.html#supporting-future-extensions","title":"Supporting future extensions","text":"<p>There are certain extensions we may want to make in the future, but we don't have a timeline for them today. Proposed approaches should take these extensions into account (e.g. the approach should be theoretically extensible), but a full proposal for implementing them is not necessary.</p> <p>These extensions are:</p> <ul> <li>Non-git subrepos</li> <li>Colocated Git repos</li> <li>The superproject using a non-git backend</li> </ul>"},{"location":"design/git-submodule-storage.html#proposed-design","title":"Proposed design","text":"<p>Git submodules will be stored as full jj repos. In the code, jj commands will only interact with the submodule's repo as an entire unit, e.g. it cannot query the submodule's commit backend directly. A well-abstracted submodule will extend well to non-git backends and non-git subrepos.</p> <p>The main challenge with this approach is that the submodule repo can be in a state that is internally valid (when considering only the submodule's repo), but invalid when considering the superproject-submodule system. This will be managed by requiring all submodule interactions go through the superproject so that superproject-submodule coordination can occur. For example, jj will not allow the user to work on the submodule's repo without going through the superproject (unlike Git).</p> <p>The notable workflows could be addressed like so:</p>"},{"location":"design/git-submodule-storage.html#fetching-submodule-commits_1","title":"Fetching submodule commits","text":"<p>The submodule would fetch using the equivalent of <code>jj git fetch</code>. It remains to be decided how a \"recursive\" fetch should work, especially if a newly fetched superproject commit references an unfetched submodule commit. A reasonable approximation would be to fetch all branches in the submodule, and then, if the submodule commit is still missing, gracefully handle it.</p>"},{"location":"design/git-submodule-storage.html#jj-op-restore-and-operation-log-format_1","title":"\"jj op restore\" and operation log format","text":"<p>As full repos, each submodule will have its own operation log. We will continue to use the existing operation log format, where each operation log tracks their own repo's commits. As commands are run in the superproject, corresponding commands will be run in the submodule as necessary, e.g. checking out a superproject commit will cause a submodule commit to also be checked out.</p> <p>Since there is no association between a superproject operation and a submodule operation, <code>jj op restore</code> in the superproject will not restore the submodule to a previous operation. Instead, the appropriate submodule operation(s) will be created. This is sufficient to preserve the superproject-submodule relationship; it precludes \"recursive\" restore (e.g. restoring branches in the superproject and submodules) but it seems unlikely that we will need such a thing.</p>"},{"location":"design/git-submodule-storage.html#nested-submodules_1","title":"Nested submodules","text":"<p>Since submodules are full repos, they can contain submodules themselves. Nesting is unlikely to complicate any of the core features, since the top-level superproject/submodule relationship is almost identical to the submodule/nested submodule relationship.</p>"},{"location":"design/git-submodule-storage.html#extending-to-colocated-git-repos","title":"Extending to colocated Git repos","text":"<p>Git expects submodules to be in <code>.git/modules</code>, so it will not understand this storage format. To support colocated Git repos, we will have to change Git to allow a submodule's gitdir to be in an alternate location (e.g. we could add a new <code>submodule.&lt;name&gt;.gitdir</code> config option). This is a simple change, so it should be feasible.</p>"},{"location":"design/git-submodule-storage.html#alternatives-considered","title":"Alternatives considered","text":""},{"location":"design/git-submodule-storage.html#git-repos-in-the-main-git-backend","title":"Git repos in the main Git backend","text":"<p>Since the Git backend contains a Git repository, an 'obvious' default would be to store them in the Git superproject the same way Git does, i.e. in <code>.git/modules</code>. Since Git submodules are full repositories that can have submodules, this storage scheme naturally extends to nested submodules.</p> <p>Most of the work in storing submodules and querying them would be well-isolated to the Git backend, which gives us a lot of flexibility to make changes without affecting the rest of jj. However, the operation log will need a significant rework since it isn't designed to reference submodules, and handling edge cases (e.g. a submodule being added/removed, nested submodules) will be tricky.</p> <p>This is rejected because handling that operation log complexity isn't worth it when very little of the work extends to non-Git backends.</p>"},{"location":"design/git-submodule-storage.html#store-git-submodules-as-alternate-git-backends","title":"Store Git submodules as alternate Git backends","text":"<p>Teach jj to use multiple commit backends and store Git submodules as Git backends. Since submodules are separate from the 'main' backend, a repository can use whatever backend it wants as its 'main' one, while still having Git submodules in the 'alternate' Git backends.</p> <p>This approach extends fairly well to non-Git submodules (which would be stored in non-Git commit backends). However, this requires significantly reworking the operation log to account for multiple commit backends. It is also not clear how nested submodules will be supported since there isn't an obvious way to represent a nested submodule's relationship to its superproject.</p>"},{"location":"design/git-submodules.html","title":"Git submodules","text":"<p>This is an aspirational document that describes how jj will support Git submodules. Readers are assumed to have some familiarity with Git and Git submodules.</p> <p>This document is a work in progress; submodules are a big feature, and relevant details will be filled in incrementally.</p>"},{"location":"design/git-submodules.html#objective","title":"Objective","text":"<p>This proposal aims to replicate the workflows users are used to with Git submodules, e.g.:</p> <ul> <li>Cloning submodules</li> <li>Making new submodule commits and updating the superproject</li> <li>Fetching and pushing updates to the submodule's remote</li> <li>Viewing submodule history</li> </ul> <p>When it is convenient, this proposal will also aim to make submodules easier to use than Git's implementation.</p>"},{"location":"design/git-submodules.html#non-goals","title":"Non-goals","text":"<ul> <li>Non-Git 'submodules' (e.g. native jj submodules, other VCSes)</li> <li>Non-Git backends (e.g. Google internal backend)</li> <li>Changing how Git submodules are implemented in Git</li> </ul>"},{"location":"design/git-submodules.html#background","title":"Background","text":"<p>We mainly want to support Git submodules for feature parity, since Git submodules are a standard feature in Git and are popular enough that we have received user requests for them. Secondarily (and distantly so), Git submodules are notoriously difficult to use, so there is an opportunity to improve the UX over Git's implementation.</p>"},{"location":"design/git-submodules.html#intro-to-git-submodules","title":"Intro to Git Submodules","text":"<p>Git submodules are a feature of Git that allow a repository (submodule) to be embedded inside another repository (the superproject). Notably, a submodule is a full repository, complete with its own index, object store and ref store. It can be interacted with like any other repository, regardless of the superproject.</p> <p>In a superproject commit, submodule information is captured in two places:</p> <ul> <li> <p>A <code>gitlink</code> entry in the commit's tree, where the value of the <code>gitlink</code> entry   is the submodule commit id. This tells Git what to populate in the working   tree.</p> </li> <li> <p>A top level <code>.gitmodules</code> file. This file is in Git's config syntax and   entries take the form <code>submodule.&lt;submodule-name&gt;.*</code>. These include many   settings about the submodules, but most importantly:</p> </li> <li> <p><code>submodule&lt;submodule-name&gt;.path</code> contains the path from the root of the tree     to the <code>gitlink</code> being described.</p> </li> <li> <p><code>submodule&lt;submodule-name&gt;.url</code> contains the url to clone the submodule     from.</p> </li> </ul> <p>In the working tree, Git notices the presence of a submodule by the <code>.git</code> entry (signifying the root of a Git repository working tree). This is either the submodule's actual Git directory (an \"old-form\" submodule), or a <code>.git</code> file pointing to <code>&lt;superproject-git-directory&gt;/modules/&lt;submodule-name&gt;</code>. The latter is sometimes called the \"absorbed form\", and is Git's preferred mode of operation.</p>"},{"location":"design/git-submodules.html#roadmap","title":"Roadmap","text":"<p>Git submodules should be implemented in an order that supports an increasing set of workflows, with the goal of getting feedback early and often. When support is incomplete, jj should not crash, but instead provide fallback behavior and warn the user where needed.</p> <p>The goal is to land good support for pure Jujutsu repositories, while colocated repositories will be supported when convenient.</p> <p>This section should be treated as a set of guidelines, not a strict order of work.</p>"},{"location":"design/git-submodules.html#phase-1-readonly-submodules","title":"Phase 1: Readonly submodules","text":"<p>This includes work that inspects submodule contents but does not create new objects in the submodule. This requires a way to store submodules in a jj repository that supports readonly operations.</p>"},{"location":"design/git-submodules.html#outcomes","title":"Outcomes","text":"<ul> <li>Submodules can be cloned anew</li> <li>New submodule commits can be fetched</li> <li>Submodule history and branches can be viewed</li> <li>Submodule contents are populated in the working copy</li> <li>Superproject gitlink can be updated to an existing submodule commit</li> <li>Conflicts in the superproject gitlink can be resolved to an existing submodule   commit</li> </ul>"},{"location":"design/git-submodules.html#phase-2-snapshotting-new-changes","title":"Phase 2: Snapshotting new changes","text":"<p>This allows a user to write new contents to a submodule and its remote.</p>"},{"location":"design/git-submodules.html#outcomes_1","title":"Outcomes","text":"<ul> <li>Changes in the working copy can be recorded in a submodule commit</li> <li>Submodule branches can be modified</li> <li>Submodules and their branches can be pushed to their remote</li> </ul>"},{"location":"design/git-submodules.html#phase-3-mergingrebasingconflicts","title":"Phase 3: Merging/rebasing/conflicts","text":"<p>This allows merging and rebasing of superproject commits in a content-aware way (in contrast to Git, where only the gitlink commit ids are compared), as well as workflows that make resolving conflicts easy and sensible.</p> <p>This can be done in tandem with Phase 2, but will likely require a significant amount of design work on its own.</p>"},{"location":"design/git-submodules.html#outcomes_2","title":"Outcomes","text":"<ul> <li>Merged/rebased submodules result in merged/rebased working copy content</li> <li>Merged/rebased working copy content can be committed, possibly by creating   sensible merged/rebased submodule commits</li> <li>Merge/rebase between submodule and non-submodule gives a sensible result</li> <li>Merge/rebase between submodule A and submodule B gives a sensible result</li> </ul>"},{"location":"design/git-submodules.html#phase-an-ideal-world","title":"Phase ?: An ideal world","text":"<p>I.e. outcomes we would like to see if there were no constraints whatsoever.</p> <ul> <li>Rewriting submodule commits rewrites descendants correctly and updates   superproject gitlinks.</li> <li>Submodule conflicts automatically resolve to the 'correct' submodule commits,   e.g. a merge between superproject commits creating a merge of the submodule   commits.</li> <li>Nested submodules are as easy to work with as non-nested submodules.</li> <li>The operation log captures changes in the submodule.</li> </ul>"},{"location":"design/git-submodules.html#design","title":"Design","text":""},{"location":"design/git-submodules.html#guiding-principles","title":"Guiding principles","text":"<p>TODO</p>"},{"location":"design/git-submodules.html#storing-submodules","title":"Storing submodules","text":"<p>Possible approaches under discussion. See ./git-submodule-storage.md.</p>"},{"location":"design/git-submodules.html#snapshotting-new-submodule-changes","title":"Snapshotting new submodule changes","text":"<p>TODO</p>"},{"location":"design/git-submodules.html#mergingrebasing-with-submodules","title":"Merging/rebasing with submodules","text":"<p>TODO</p>"},{"location":"design/tracking-branches.html","title":"Remote/<code>@git</code> tracking branches","text":"<p>This is a plan to implement more Git-like remote tracking branch UX.</p>"},{"location":"design/tracking-branches.html#objective","title":"Objective","text":"<p><code>jj</code> imports all remote branches to local branches by default. As described in #1136, this doesn't interact nicely with Git if we have multiple Git remotes with a number of branches. The <code>git.auto-local-branch</code> config can mitigate this problem, but we'll get locally-deleted branches instead.</p> <p>The goal of this plan is to implement * proper support for tracking/non-tracking remote branches * logically consistent data model for importing/exporting Git refs</p>"},{"location":"design/tracking-branches.html#current-data-model-as-of-jj-080","title":"Current data model (as of jj 0.8.0)","text":"<p>Under the current model, all remote branches are \"tracking\" branches, and remote changes are merged into the local counterparts.</p> <pre><code>branches\n  [name]:\n    local_target?\n    remote_targets[remote]: target\ntags\n  [name]: target\ngit_refs\n  [\"refs/heads/{name}\"]: target             # last-known local branches\n  [\"refs/remotes/{remote}/{name}\"]: target  # last-known remote branches\n                                            # (copied to remote_targets)\n  [\"refs/tags/{name}\"]: target              # last-known tags\ngit_head: target?\n</code></pre> <ul> <li>Remote branches are stored in both <code>branches[name].remote_targets</code> and   <code>git_refs[\"refs/remotes\"]</code>. These two are kept in sync unless the branch is   removed by <code>jj branch forget</code> command.</li> <li>Pseudo <code>@git</code> remote branches are stored in <code>git_refs[\"refs/heads\"]</code>.</li> </ul>"},{"location":"design/tracking-branches.html#proposed-data-model","title":"Proposed data model","text":"<p>We'll add a per-remote-branch <code>state</code> to distinguish non-tracking branches from tracking ones.</p> <pre><code>state = new        # not merged in the local branch or tag\n      | tracking   # merged in the local branch or tag\n      | forgotten  # to be expunged on the next export\n# `ignored` state could be added if we want to manage it by view, not by\n# config file. target of ignored remote branch would be absent.\n</code></pre> <p>We'll add a per-remote view-like object to record the last known remote branches. It will replace <code>git_refs</code> and <code>branches[name].remote_targets</code> in the current model.</p> <pre><code>branches\n  [name]: target\ntags\n  [name]: target\nremotes\n  [\"git\"]:\n    branches\n      [name]: target, state                 # refs/heads/{name}\n    tags\n      [name]: target, state = tracking      # refs/tags/{name}\n    head: target?, state = TBD              # refs/HEAD\n  [remote]:\n    branches\n      [name]: target, state                 # refs/remotes/{remote}/{name}\n    tags: (empty)\n    head: (empty)\n</code></pre> <p>With the proposed data model, we can * naturally support remote branches which have no local counterparts * deduplicate <code>branches[name].remote_targets</code> and <code>git_refs[\"refs/remotes\"]</code> * eliminate <code>git_</code> variables and methods from the view object</p> <p>The <code>git.auto-local-branch</code> config knob is applied when importing new remote branch. <code>jj branch</code> sub commands will be added to change the tracking state.</p> <pre><code>fn default_state_for_newly_imported_branch(config, remote) {\nif remote == \"git\" {\nState::Tracking\n} else if config[\"git.auto-local-branch\"] {\nState::Tracking\n} else {\nState::New\n}\n}\n</code></pre> <p>A branch target to be merged is calculated based on the <code>state</code>.</p> <pre><code>fn target_in_merge_context(known_target, state) {\nmatch state {\nState::New =&gt; RefTarget::absent(),\nState::Tracking =&gt; known_target,\nState::Forgotten =&gt; RefTarget::absent(),\n}\n}\n</code></pre>"},{"location":"design/tracking-branches.html#mapping-to-the-current-data-model","title":"Mapping to the current data model","text":"<ul> <li>New <code>remotes[\"git\"].branches</code> corresponds to <code>git_refs[\"refs/heads\"]</code>.</li> <li>New <code>remotes[\"git\"].tags</code> corresponds to <code>git_refs[\"refs/tags\"]</code>.</li> <li>New <code>remotes[\"git\"].head</code> corresponds to <code>git_head</code>.</li> <li>New <code>remotes[remote].branches</code> corresponds to   <code>git_refs[\"refs/remotes/{remote}\"]</code> and <code>branches[].remote_targets[remote]</code>.</li> <li>If <code>git_refs[\"refs/remotes/{remote}\"]</code> exists but <code>.remote_targets</code> doesn't,   it means <code>state = forgotten</code> in new model.</li> <li><code>state = new|tracking</code> doesn't exist in the current model. It's determined   by <code>git.auto-local-branch</code> config.</li> </ul>"},{"location":"design/tracking-branches.html#common-command-behaviors","title":"Common command behaviors","text":"<p>In the following sections, a merge is expressed as <code>adds - removes</code>. In particular, a merge of local and remote targets is <code>[local, remote] - [known_remote]</code>.</p>"},{"location":"design/tracking-branches.html#fetchimport","title":"fetch/import","text":"<ul> <li> <p><code>jj git fetch</code>   1. Fetches remote changes to the backing Git repo.   2. Import changes only for <code>remotes[remote].branches[glob]</code> (see below)</p> <ul> <li>TODO: how about fetched <code>.tags</code>?</li> </ul> </li> <li> <p><code>jj git import</code>   1. Calculates diff from the known <code>remotes</code> to the actual git repo.</p> <ul> <li><code>\"refs/heads\" - remotes[\"git\"].branches</code></li> <li><code>\"refs/tags\" - remotes[\"git\"].tags</code></li> <li><code>\"HEAD\" - remotes[\"git\"].head</code> (unused)</li> <li><code>\"refs/remotes/{remote}\" - remotes[remote]</code>   2. Merges diff in local <code>branches</code> and <code>tags</code> if <code>state</code> is <code>tracking</code>.</li> <li>If the branch is new, the default <code>state</code> should be calculated.</li> <li>If <code>state</code> is <code>forgotten</code>, the known branch is supposed to be removed,    and the default <code>state</code> should be calculated.   3. Updates <code>remotes</code> reflecting the import.</li> <li><code>absent</code> entries are removed from <code>remotes</code>.   4. Abandons commits that are no longer referenced.</li> </ul> </li> </ul>"},{"location":"design/tracking-branches.html#pushexport","title":"push/export","text":"<ul> <li> <p><code>jj git push</code>   1. Calculates diff from the known <code>remotes[remote]</code> to the local changes.</p> <ul> <li><code>branches - remotes[remote].branches</code></li> <li>If <code>state</code> is <code>new|forgotten</code> (i.e. untracked), the known remote      branch <code>target</code> is considered <code>absent</code>.</li> <li>If <code>state</code> is <code>new|forgotten</code>, and if the local branch <code>target</code> is      <code>absent</code>, the diff <code>[absent, remote] - absent</code> is noop. So it's not      allowed to push deleted branch to untracked remote.</li> <li>TODO: Copy Git's <code>--force-with-lease</code> behavior?</li> <li>~<code>tags</code>~ (not implemented, but should be the same as <code>branches</code>)   2. Pushes diff to the remote Git repo (as well as remote tracking branches  in the backing Git repo.)   3. Sets <code>remotes[remote].branches[name].state = tracking</code>   4. Import changes only for <code>remotes[remote].branches[glob]</code></li> </ul> </li> <li> <p><code>jj git export</code>   1. Calculates diff from the known <code>remotes[\"git\"]</code> to the local changes      and forgotten branches.</p> <ul> <li><code>branches - remotes[\"git\"].branches</code> if <code>state</code> is <code>tracking</code></li> <li>If <code>remotes[\"git\"].branches[name]</code> is <code>absent</code>, the default      <code>state = tracking</code> applies.</li> <li>If <code>state</code> is <code>forgotten</code> but local branch exists,      <code>remotes[\"git\"].branches[name]</code> is supposed to be removed, and      the default <code>state = tracking</code> applies.</li> <li>~<code>tags</code>~ (not implemented, but should be the same as <code>branches</code>)</li> <li><code>absent - remotes[remote].branches</code> if <code>state</code> is <code>forgotten</code>   2. Applies diff to the backing Git repo.   3. Updates <code>remotes</code> reflecting the export.</li> <li><code>absent</code> entries are removed from <code>remotes</code>.</li> </ul> </li> </ul>"},{"location":"design/tracking-branches.html#initclone","title":"init/clone","text":"<ul> <li><code>jj init</code></li> <li>Import, track, and merge per <code>git.auto_local_branch</code> config.</li> <li> <p>If <code>!git.auto_local_branch</code>, no <code>tracking</code> state will be set.</p> </li> <li> <p><code>jj git clone</code></p> </li> <li>Import, track, and merge per <code>git.auto_local_branch</code> config.</li> <li>The default branch will be tracked regardless of <code>git.auto_local_branch</code>     config. (Because local branch is created for the default remote branch,     it makes sense to track.)</li> </ul>"},{"location":"design/tracking-branches.html#branch","title":"branch","text":"<ul> <li><code>jj branch set {name}</code>   1. Sets local <code>branches[name]</code> entry.</li> <li><code>jj branch delete {name}</code>   1. Removes local <code>branches[name]</code> entry.</li> <li><code>jj branch forget {name}</code>   1. Removes local <code>branches[name]</code> entry if exists.   2. Sets all <code>remotes[remote].branches[name].state = forgotten</code>.</li> <li><code>jj branch track {name}@{remote}</code> (new command)   1. Merges <code>[local, remote] - [absent]</code> in local branch.<ul> <li>Same as \"fetching/importing existing branch from untracked remote\".   2. Sets <code>remotes[remote].branches[name].state = tracking</code>.</li> </ul> </li> <li><code>jj branch untrack {name}@{remote}</code> (new command)   1. Sets <code>remotes[remote].branches[name].state = new</code>.</li> <li><code>jj branch list</code></li> <li>TODO: hide non-tracking branches by default? ...</li> </ul> <p>Note: desired behavior of <code>jj branch forget</code> is to * discard both local and remote branches (without actually removing branches   at remotes) * not abandon commits which belongs to those branches (even if the branch is   removed at a remote)</p>"},{"location":"design/tracking-branches.html#command-behavior-examples","title":"Command behavior examples","text":""},{"location":"design/tracking-branches.html#fetchimport_1","title":"fetch/import","text":"<ul> <li>Fetching/importing new branch   1. Decides new <code>state = new|tracking</code> based on <code>git.auto_local_branch</code>   2. If new <code>state</code> is <code>tracking</code>, merges <code>[absent, new_remote] - [absent]</code>      (i.e. creates local branch with <code>new_remote</code> target)   3. Sets <code>remotes[remote].branches[name].state</code></li> <li>Fetching/importing existing branch from tracking remote   1. Merges <code>[local, new_remote] - [known_remote]</code></li> <li>Fetching/importing existing branch from untracked remote   1. Decides new <code>state = new|tracking</code> based on <code>git.auto_local_branch</code>   2. If new <code>state</code> is <code>tracking</code>, merges <code>[local, new_remote] - [absent]</code>   3. Sets <code>remotes[remote].branches[name].state</code></li> <li>Fetching/importing remotely-deleted branch from tracking remote   1. Merges <code>[local, absent] - [known_remote]</code>   2. Removes <code>remotes[remote].branches[name]</code> (<code>target</code> becomes <code>absent</code>)      (i.e. the remote branch is no longer tracked)   3. Abandons commits in the deleted branch</li> <li>Fetching/importing remotely-deleted branch from untracked remote   1. Decides new <code>state = new|tracking</code> based on <code>git.auto_local_branch</code>   2. Noop anyway since <code>[local, absent] - [absent]</code> -&gt; <code>local</code></li> <li>Fetching previously-forgotten branch from remote   1. Decides new <code>state = new|tracking</code> based on <code>git.auto_local_branch</code>   2. If new <code>state</code> is <code>tracking</code>, merges     <code>[absent, new_remote] - [absent]</code> -&gt; <code>new_remote</code>      (The known <code>target</code> of forgotten remote branch is <code>absent</code>)   3. Sets <code>remotes[remote].branches[name].state</code></li> <li>Fetching forgotten and remotely-deleted branch</li> <li>Same as \"remotely-deleted branch from untracked remote\" since <code>forgotten</code>     remote branch should never be <code>tracking</code></li> <li>Therefore, no local commits should be abandoned</li> </ul>"},{"location":"design/tracking-branches.html#pushexport_1","title":"push/export","text":"<ul> <li>Pushing/exporting new branch, remote doesn't exist   1. Exports <code>[local, absent] - [absent]</code> -&gt; <code>local</code>   2. Sets <code>remotes[remote].branches[name].state = tracking</code>   3. <code>import_refs()</code> merges <code>[local, local] - [absent]</code> -&gt; <code>local</code> (noop)</li> <li>Pushing/exporting new branch, untracked remote exists   1. Exports <code>[local, remote] - [absent]</code><ul> <li>Fails if <code>local</code> moved backwards or sideways   2. Sets <code>remotes[remote].branches[name].state = tracking</code>   3. <code>import_refs()</code> merges <code>[local, local] - [remote]</code> -&gt; <code>local</code> (noop)</li> </ul> </li> <li>Pushing/exporting existing branch to tracking remote   1. Exports <code>[local, remote] - [remote]</code> -&gt; <code>local</code><ul> <li>Fails if <code>local</code> moved backwards or sideways, and if <code>remote</code> is out of    sync   2. <code>import_refs()</code> merges <code>[local, local] - [remote]</code> -&gt; <code>local</code> (noop)</li> </ul> </li> <li>Pushing/exporting existing branch to untracked remote</li> <li>Same as \"new branch\"</li> <li>Pushing/exporting deleted branch to tracking remote   1. Exports <code>[absent, remote] - [remote]</code> -&gt; <code>absent</code><ul> <li>TODO: Fails if <code>remote</code> is out of sync?   2. <code>import_refs()</code> merges <code>[absent, absent] - [remote]</code> -&gt; <code>absent</code>   3. Removes <code>remotes[remote].branches[name]</code> (<code>target</code> becomes <code>absent</code>)</li> </ul> </li> <li>Pushing/exporting deleted branch to untracked remote</li> <li>Noop since <code>[absent, remote] - [absent]</code> -&gt; <code>remote</code></li> <li>Perhaps, UI will report error</li> <li>Pushing forgotten branch to untracked remote</li> <li>Same as \"deleted branch to untracked remote\"</li> <li>Exporting forgotten branch   1. Local branch change is noop since <code>[absent, absent] - [absent]</code> -&gt; <code>absent</code>   2. Exports <code>forgotten</code> state to the backing Git repo:     <code>[absent, known_remote] - [known_remote]</code> -&gt; <code>absent</code>     (This includes local branch in the pseudo <code>\"git\"</code> remote)   3. Removes <code>remotes[remote].branches[name]</code> (<code>target</code> becomes <code>absent</code>)</li> <li>Pushing previously-forgotten branch to remote</li> <li>Same as \"new branch, untracked remote exists\"</li> <li>The known <code>target</code> of forgotten remote branch is <code>absent</code></li> </ul>"},{"location":"design/tracking-branches.html#git-remote","title":"<code>@git</code> remote","text":"<ul> <li><code>jj branch untrack {name}@git</code></li> <li>Maybe rejected (to avoid confusion)?</li> <li>Allowing this would mean different local branches of the same name coexist     in jj and git.</li> <li><code>jj git fetch --remote git</code></li> <li>Maybe rejected (to avoid confusion)?</li> <li>Conceptually, it's <code>git::import_refs()</code> only for local branches.</li> <li><code>jj git push --remote git</code></li> <li>Maybe rejected (to avoid confusion)?</li> <li>Conceptually, it's <code>jj branch track</code> and <code>git::export_refs()</code> only for     local branches.</li> </ul>"},{"location":"design/tracking-branches.html#remaining-issues","title":"Remaining issues","text":"<ul> <li><code>git.auto_local_branch = false</code> by default to help Git interop?</li> <li>https://github.com/martinvonz/jj/issues/1862</li> <li>https://github.com/martinvonz/jj/issues/1278 pushing to tracked remote</li> <li>Option could be added to push to all <code>tracking</code> remotes?</li> <li>Track remote branch locally with different name</li> <li>Local branch name could be stored per remote branch</li> <li>Consider UI complexity</li> <li>\"private\" state (suggested by @ilyagr)</li> <li>\"private\" branches can be pushed to their own remote, but not to the     upstream repo</li> <li>This might be a state attached to a local branch (similar to Mercurial's     \"secret\" phase)</li> </ul>"},{"location":"design/tracking-branches.html#references","title":"References","text":"<ul> <li>https://github.com/martinvonz/jj/issues/1136</li> <li>https://github.com/martinvonz/jj/issues/1666</li> <li>https://github.com/martinvonz/jj/issues/1690</li> <li>https://github.com/martinvonz/jj/issues/1734</li> <li>https://github.com/martinvonz/jj/pull/1739</li> </ul>"},{"location":"technical/architecture.html","title":"Architecture","text":""},{"location":"technical/architecture.html#data-model","title":"Data model","text":"<p>The commit data model is similar to Git's object model , but with some differences.</p>"},{"location":"technical/architecture.html#separation-of-library-from-ui","title":"Separation of library from UI","text":"<p>The <code>jj</code> binary consists of two Rust crates: the library crate (<code>jj-lib</code>) and the CLI crate (<code>jj-cli</code>). The library crate is currently only used by the CLI crate, but it is meant to also be usable from a GUI or TUI, or in a server serving requests from multiple users. As a result, the library should avoid interacting directly with the user via the terminal or by other means; all input/output is handled by the CLI crate <sup>1</sup>. Since the library crate is meant to usable in a server, it also cannot read configuration from the user's home directory, or from user-specific environment variables.</p> <p>A lot of thought has gone into making the library crate's API easy to use, but not much has gone into \"details\" such as which collection types are used, or which symbols are exposed in the API.</p>"},{"location":"technical/architecture.html#storage-independent-apis","title":"Storage-independent APIs","text":"<p>One overarching principle in the design is that it should be easy to change where data is stored. The goal was to be able to put storage on local-disk by default but also be able to move storage to the cloud at Google (and for anyone). To that end, commits (and trees, files, etc.) are stored by the commit backend, operations (and views) are stored by the operation backend, the heads of the operation log are stored by the \"op heads\" backend, the commit index is stored by the index backend, and the working copy is stored by the working copy backend. The interfaces are defined in terms of plain Rust data types, not tied to a specific format. The working copy doesn't have its own trait defined yet, but its interface is small and easy to create traits for when needed.</p> <p>The commit backend to use when loading a repo is specified in the <code>.jj/repo/store/type</code> file. There are similar files for the other backends (<code>.jj/repo/index/type</code>, <code>.jj/repo/op_store/type</code>, <code>.jj/repo/op_heads/type</code>).</p>"},{"location":"technical/architecture.html#design-of-the-library-crate","title":"Design of the library crate","text":""},{"location":"technical/architecture.html#overview","title":"Overview","text":"<p>Here's a diagram showing some important types in the library crate. The following sections describe each component.</p> <pre><code>graph TD;\n    ReadonlyRepo--&gt;Store;\n    ReadonlyRepo--&gt;OpStore;\n    ReadonlyRepo--&gt;OpHeadsStore;\n    ReadonlyRepo--&gt;ReadonlyIndex\n    MutableIndex--&gt;ReadonlyIndex;\n    Store--&gt;Backend;\n    GitBackend--&gt;Backend;\n    LocalBackend--&gt;Backend;\n    LocalBackend--&gt;StackedTable;\n    MutableRepo--&gt;ReadonlyRepo;\n    MutableRepo--&gt;MutableIndex;\n    Transaction--&gt;MutableRepo;\n    WorkingCopy--&gt;TreeState;\n    Workspace--&gt;WorkingCopy;\n    Workspace--&gt;RepoLoader;\n    RepoLoader--&gt;Store;\n    RepoLoader--&gt;OpStore;\n    RepoLoader--&gt;OpHeadsStore;\n    RepoLoader--&gt;ReadonlyRepo;\n    Git--&gt;GitBackend;\n    GitBackend--&gt;StackedTable;\n</code></pre>"},{"location":"technical/architecture.html#backend","title":"Backend","text":"<p>The <code>Backend</code> trait defines the interface each commit backend needs to implement. The current in-tree commit backends are <code>GitBackend</code> and <code>LocalBackend</code>.</p> <p>Since there are non-commit backends, the <code>Backend</code> trait should probably be renamed to <code>CommitBackend</code>.</p>"},{"location":"technical/architecture.html#gitbackend","title":"GitBackend","text":"<p>The <code>GitBackend</code> stores commits in a Git repository. It uses <code>libgit2</code> to read and write commits and refs.</p> <p>To prevent GC from deleting commits that are still reachable from the operation log, the <code>GitBackend</code> stores a ref for each commit in the operation log in the <code>refs/jj/keep/</code> namespace.</p> <p>Commit data that is available in Jujutsu's model but not in Git's model is stored in a <code>StackedTable</code> in <code>.jj/repo/store/extra/</code>. That is currently the change ID and the list of predecessors. For commits that don't have any data in that table, which is any commit created by <code>git</code>, we use an empty list as predecessors, and the bit-reversed commit ID as change ID.</p> <p>Because we use the Git Object ID as commit ID, two commits that differ only in their change ID, for example, will get the same commit ID, so we error out when trying to write the second one of them.</p>"},{"location":"technical/architecture.html#localbackend","title":"LocalBackend","text":"<p>The <code>LocalBackend</code> is just a proof of concept. It stores objects addressed by their hash, with one file per object.</p>"},{"location":"technical/architecture.html#store","title":"Store","text":"<p>The <code>Store</code> type wraps the <code>Backend</code> and returns wrapped types for commits and trees to make them easier to use. The wrapped objects have a reference to the <code>Store</code> itself, so you can do e.g. <code>commit.parents()</code> without having to provide the <code>Store</code> as an argument.</p> <p>The <code>Store</code> type also provides caching of commits and trees.</p>"},{"location":"technical/architecture.html#readonlyrepo","title":"ReadonlyRepo","text":"<p>A <code>ReadonlyRepo</code> represents the state of a repo at a specific operation. It keeps the view object associated with that operation.</p> <p>The repository doesn't know where on disk any working copies live. It knows, via the view object, which commit is supposed to be the current working-copy commit in each workspace.</p>"},{"location":"technical/architecture.html#mutablerepo","title":"MutableRepo","text":"<p>A <code>MutableRepo</code> is a mutable version of <code>ReadonlyRepo</code>. It has a reference to its base <code>ReadonlyRepo</code>, but it has its own copy of the view object and lets the caller modify it.</p>"},{"location":"technical/architecture.html#transaction","title":"Transaction","text":"<p>The <code>Transaction</code> object has a <code>MutableRepo</code> and metadata that will go into the operation log. When the transaction commits, the <code>MutableRepo</code> becomes a view object in the operation log on disk, and the <code>Transaction</code> object becomes an operation object. In memory, <code>Transaction::commit()</code> returns a new <code>ReadonlyRepo</code>.</p>"},{"location":"technical/architecture.html#repoloader","title":"RepoLoader","text":"<p>The <code>RepoLoader</code> represents a repository at an unspecified operation. You can think of as a pointer to the <code>.jj/repo/</code> directory. It can create a <code>ReadonlyRepo</code> given an operation ID.</p>"},{"location":"technical/architecture.html#treestate","title":"TreeState","text":"<p>The <code>TreeState</code> type represents the state of the files in a working copy. It keep track of the mtime and size for each tracked file. It knows the <code>TreeId</code> that the working copy represents. It has a <code>snapshot()</code> method that will use the recorded mtimes and sizes and detect changes in the working copy. If anything changed, it will return a new <code>TreeId</code>. It also has <code>checkout()</code> for updating the files on disk to match a requested <code>TreeId</code>.</p> <p>The <code>TreeState</code> type supports sparse checkouts. In fact, all working copies are sparse; they simply track the full repo in most cases.</p>"},{"location":"technical/architecture.html#workingcopy","title":"WorkingCopy","text":"<p>The <code>WorkingCopy</code> type has a <code>TreeState</code> but also knows which <code>WorkspaceId</code> it has and at which operation it was most recently updated.</p>"},{"location":"technical/architecture.html#workspace","title":"Workspace","text":"<p>The <code>Workspace</code> type represents the combination of a repo and a working copy ( like Git's 'worktree' concept).</p> <p>The repo view at the current operation determines the desired working-copy commit in each workspace. The <code>WorkingCopy</code> determines what is actually in the working copy. The working copy can become stale if the working-copy commit was changed from another workspace (or if the process updating the working copy crashed, for example).</p>"},{"location":"technical/architecture.html#git","title":"Git","text":"<p>The <code>git</code> module contains functionality for interoperating with a Git repo, at a higher level than the <code>GitBackend</code>. The <code>GitBackend</code> is restricted by the <code>Backend</code> trait; the <code>git</code> module is specifically for Git-backed repos. It has functionality for importing refs from the Git repo and for exporting to refs in the Git repo. It also has functionality for pushing and pulling to/from Git remotes.</p>"},{"location":"technical/architecture.html#revsets","title":"Revsets","text":"<p>A user-provided revset expression string goes through a few different stages to be evaluated:</p> <ol> <li>Parse the expression into a <code>RevsetExpression</code>, which is close to an AST</li> <li>Resolve symbols and functions like <code>tags()</code> into specific commits. After    this stage, the expression is still a <code>RevsetExpression</code>, but it won't have    any <code>CommitRef</code> variants in it.</li> <li>Resolve visibility. This stage resolves <code>visible_heads()</code> and <code>all()</code> and    produces a <code>ResolvedExpression</code>.</li> <li>Evaluate the <code>ResolvedExpression</code> into a <code>Revset</code>.</li> </ol> <p>This evaluation step is performed by <code>Index::evaluate_revset()</code>, allowing the <code>Revset</code> implementation to leverage the specifics of a custom index implementation. The first three steps are independent of the index implementation.</p>"},{"location":"technical/architecture.html#stackedtable","title":"StackedTable","text":"<p><code>StackedTable</code> (actually <code>ReadonlyTable</code> and <code>MutableTable</code>) is a simple disk format for storing key-value pairs sorted by key. The keys have to have the same size but the values can have different sizes. We use our own format because we want lock-free concurrency and there doesn't seem to be an existing key-value store we could use.</p> <p>The file format contains a lookup table followed by concatenated values. The lookup table is a sorted list of keys, where each key is followed by the associated value's offset in the concatenated values.</p> <p>A table can have a parent table. When looking up a key, if it's not found in the current table, the parent table is searched. We never update a table in place. If the number of new entries to write is less than half the number of entries in the parent table, we create a new table with the new entries and a pointer to the parent. Otherwise, we copy the entries from the parent table and the new entries into a new table with the grandparent as the parent. We do that recursively so parent tables are at least 2 times as large as child tables. This results in O(log N) amortized insertion time and lookup time.</p> <p>There's no garbage collection of unreachable tables yet.</p> <p>The tables are named by their hash. We keep a separate directory of pointers to the current leaf tables, in the same way as we do for the operation log.</p>"},{"location":"technical/architecture.html#design-of-the-cli-crate","title":"Design of the CLI crate","text":""},{"location":"technical/architecture.html#templates","title":"Templates","text":"<p>The concept is copied from Mercurial, but the syntax is different. The main difference is that the top-level expression is a template expression, not a string like in Mercurial. There is also no string interpolation (e.g. <code>\"Commit ID: {node}\"</code> in Mercurial).</p>"},{"location":"technical/architecture.html#diff-editing","title":"Diff-editing","text":"<p>Diff-editing works by creating two very sparse working copies, containing only the files we want the user to edit. We then let the user edit the right-hand side of the diff. Then we simply snapshot that working copy to create the new tree.</p> <ol> <li> <p>There are a few exceptions, such as for messages printed during automatic upgrades of the repo format\u00a0\u21a9</p> </li> </ol>"},{"location":"technical/concurrency.html","title":"Concurrency","text":""},{"location":"technical/concurrency.html#introduction","title":"Introduction","text":"<p>Concurrent editing is a key feature of DVCSs -- that's why they're called Distributed Version Control Systems. A DVCS that didn't let users edit files and create commits on separate machines at the same time wouldn't be much of a distributed VCS.</p> <p>When conflicting changes are made in different clones, a DVCS will have to deal with that when you push or pull. For example, when using Mercurial, if the remote has updated a bookmark called <code>main</code> (Mercurial's bookmarks are similar to a Git's branches) and you had updated the same bookmark locally but made it point to a different target, Mercurial would add a bookmark called <code>main@origin</code> to indicate the conflict. Git instead prevents the conflict by renaming pulled branches to <code>origin/main</code> whether or not there was a conflict. However, most DVCSs treat local concurrency quite differently, typically by using lock files to prevent concurrent edits. Unlike those DVCSs, Jujutsu treats concurrent edits the same whether they're made locally or remotely.</p> <p>One problem with using lock files is that they don't work when the clone is in a distributed file system. Most clones are of course not stored in distributed file systems, but it is a big problem when they are (Mercurial repos frequently get corrupted, for example).</p> <p>Another problem with using lock files is related to complexity of implementation. The simplest way of using lock files is to take coarse-grained locks early: every command that may modify the repo takes a lock at the very beginning. However, that means that operations that wouldn't actually conflict would still have to wait for each other. The user experience can be improved by using finer-grained locks and/or taking the locks later. The drawback of that is complexity. For example, you need to verify that any assumptions you made before locking are still valid after you take the lock.</p> <p>To avoid depending on lock files, Jujutsu takes a different approach by accepting that concurrent changes can always happen. It instead exposes any conflicting changes to the user, much like other DVCSs do for conflicting changes made remotely.</p>"},{"location":"technical/concurrency.html#syncing-with-rsync-nfs-dropbox-etc","title":"Syncing with <code>rsync</code>, NFS, Dropbox, etc","text":"<p>Jujutsu's lock-free concurrency means that it's possible to update copies of the clone on different machines and then let <code>rsync</code> (or Dropbox, or NFS, etc.) merge them. The working copy may mismatch what's supposed to be checked out, but no changes to the repo will be lost (added commits, moved branches, etc.). If conflicting changes were made, they will appear as conflicts. For example, if a branch was moved to two different locations, they will appear in <code>jj log</code> in both locations but with a \"?\" after the name, and <code>jj status</code> will also inform the user about the conflict.</p> <p>Note that, for now, there are known bugs in this area. Most notably, with the Git backend, repository corruption is possible because the backend is not entirely lock-free. If you know about the bug, it is relatively easy to recover from.</p> <p>Moreover, such use of Jujutsu is not currently thoroughly tested, especially in the context of co-located repositories. While the contents of commits should be safe, concurrent modification of a repository from different computers might conceivably lose some branch pointers. Note that, unlike in pure Git, losing a branch pointer does not lead to losing commits.</p>"},{"location":"technical/concurrency.html#operation-log","title":"Operation log","text":"<p>The most important piece in the lock-free design is the \"operation log\". That is what allows us to detect and merge concurrent operations.</p> <p>The operation log is similar to a commit DAG (such as in Git's object model), but each commit object is instead an \"operation\" and each tree object is instead a \"view\". The view object contains the set of visible head commits, branches, tags, and the working-copy commit in each workspace. The operation object contains a pointer to the view object (like how commit objects point to tree objects), pointers to parent operation(s) (like how commit objects point to parent commit(s)), and metadata about the operation. These types are defined in <code>op_store.proto</code> The operation log is normally linear. It becomes non-linear if there are concurrent operations.</p> <p>When a command starts, it loads the repo at the latest operation. Because the associated view object completely defines the repo state, the running command will not see any changes made by other processes thereafter. When the operation completes, it is written with the start operation as parent. The operation cannot fail to commit (except for disk failures and such). It is left for the next command to notice if there were concurrent operations. It will have to be able to do that anyway since the concurrent operation could have arrived via a distributed file system. This model -- where each operation sees a consistent view of the repo and is guaranteed to be able to commit their changes -- greatly simplifies the implementation of commands.</p> <p>It is possible to load the repo at a particular operation with <code>jj --at-operation=&lt;operation ID&gt; &lt;command&gt;</code>. If the command is mutational, that will result in a fork in the operation log. That works exactly the same as if any later operations had not existed when the command started. In other words, running commands on a repo loaded at an earlier operation works the same way as if the operations had been concurrent. This can be useful for simulating concurrent operations.</p>"},{"location":"technical/concurrency.html#merging-concurrent-operations","title":"Merging concurrent operations","text":"<p>If Jujutsu tries to load the repo and finds multiple heads in the operation log, it will do a 3-way merge of the view objects based on their common ancestor (possibly several 3-way merges if there were more than two heads). Conflicts are recorded in the resulting view object. For example, if branch <code>main</code> was moved from commit A to commit B in one operation and moved to commit C in a concurrent operation, then <code>main</code> will be recorded as \"moved from A to B or C\". See the <code>RefTarget</code> definition in <code>op_store.proto</code>.</p> <p>Because we allow branches (etc.) to be in a conflicted state rather than just erroring out when there are multiple heads, the user can continue to use the repo, including performing further operations on the repo. Of course, some commands will fail when using a conflicted branch. For example, <code>jj checkout main</code> when <code>main</code> is in a conflicted state will result in an error telling you that <code>main</code> resolved to multiple revisions.</p>"},{"location":"technical/concurrency.html#storage","title":"Storage","text":"<p>The operation objects and view objects are stored in content-addressed storage just like Git commits are. That makes them safe to write without locking.</p> <p>We also need a way of finding the current head of the operation log. We do that by keeping the ID of the current head(s) as a file in a directory. The ID is the name of the file; it has no contents. When an operation completes, we add a file pointing to the new operation and then remove the file pointing to the old operation. Writing the new file is what makes the operation visible (if the old file didn't get properly deleted, then future readers will take care of that). This scheme ensures that transactions are atomic.</p>"},{"location":"technical/conflicts.html","title":"First-class conflicts","text":""},{"location":"technical/conflicts.html#introduction","title":"Introduction","text":"<p>Conflicts can happen when two changes are applied to some state. This document is about conflicts between changes to files (not about conflicts between changes to branch targets, for example).</p> <p>For example, if you merge two branches in a repo, there may be conflicting changes between the two branches. Most DVCSs require you to resolve those conflicts before you can finish the merge operation. Jujutsu instead records the conflicts in the commit and lets you resolve the conflict when you feel like it. </p>"},{"location":"technical/conflicts.html#data-model","title":"Data model","text":"<p>When a merge conflict happens, it is recorded within the tree object as a special conflict object (not a file object with conflict markers). Conflicts are stored as a lists of states to add and another list of states to remove. A \"state\" here can be a normal file, a symlink, or a tree. These two lists together can be a viewed as a simple algebraic expression of positive and negative terms. The order of terms is undefined.</p> <p>For example, a regular 3-way merge between B and C, with A as base, is <code>B+C-A</code> (<code>{ removes=[A], adds=[B,C] }</code>). A modify/remove conflict is <code>B-A</code>. An add/add conflict is <code>B+C</code>. An octopus merge of N commits usually has N positive terms and N-1 negative terms. A non-conflict state A is equivalent to a conflict state containing just the term <code>A</code>. An empty expression indicates absence of any content at that path. A conflict can thus encode a superset of what can be encoded in a regular path state.</p>"},{"location":"technical/conflicts.html#conflict-simplification","title":"Conflict simplification","text":"<p>Remember that a 3-way merge can be written <code>B+C-A</code>. If one of those states is itself a conflict, then we simply insert the conflict expression there. Then we simplify by removing canceling terms.</p> <p>For example, let's say commit B is based on A and is rebased to C, where it results in conflicts (<code>B+C-A</code>), which the user leaves unresolved. If the commit is then rebased to D, the result will be <code>(B+C-A)+(D-C)</code> (<code>D-C</code> comes from changing the base from C to D). That expression can be simplified to <code>B+D-A</code>, which is a regular 3-way merge between B and D with A as base (no trace of C). This is what lets the user keep old commits rebased to head without resolving conflicts and still not get messy recursive conflicts.</p> <p>As another example, let's go through what happens when you back out a conflicted commit. Let's say we have the usual <code>B+C-A</code> conflict on top of non-conflict state C. We then back out that change. Backing out (\"reverting\" in Git-speak) a change means applying its reverse diff, so the result is <code>(B+C-A)+(A-(B+C-A))</code>, which we can simplify to just <code>A</code> (i.e. no conflict).</p>"}]}